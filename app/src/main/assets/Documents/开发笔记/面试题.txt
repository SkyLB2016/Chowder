IO流


●01.java中equal与==的区别
1）基本数据类型==比较的是值，非基本类型比较的是内存地址
2）Object默认equal比较的是内存地址。可重写。

●02.handler机制与RaJava有什么区别：相同都是为了线程间通信
1）Rxjava线程切换更方便，可以直接切换子线程和UI线程，handler需要在子线程中发送消息，在主线程中去接收消息，才能改变UI。
2）RxJava是观察者模式，Handler消息队列用的是双向链表，也就是责任链模式。

●03.广播有几种创建方式，有什么区别？
两种，动态注册和静态注册（8.0以后不能静态注册广播，官方说法是为了省电）；区别：
1）动态注册的广播永远要快于静态注册的广播，不管静态注册的优先级设置的多高，不管动态注册的优先级有多低。也就是和设置优先级无关，动态就是比静态快。
2）动态注册广播不是常住性广播，也就是说广播跟随activity的生命周期。注意：activity调用ondestory，移除广播接收器。静态注册是常驻型，不能自动销毁，应用程序关闭后，如有信息广播来，程序也会被系统调用自动运行。
3）在同一个优先级下，谁嫌弃都弄得快，谁将先接收到广播。

●04.Android的数据存储方式有哪些
1）Shardpreferences（适合轻量级数据存储，采用xml键值对的形式存储到本地，只能用于一个app内）
2）文本文件存储（序列化与反序列化）
3）SQLite数据库存储
4）ContentProvider
5）网络存储

●05.服务的启动方式和对应的生命周期以及区别
1）startService（onCreate-（onStart已舍弃）-onStartCommand-onDestory）
服务于启动者没有必然的联系，启动者销毁，服务也可以存在；只有主动调用StopService方法才能停止。
2）bindService（onCreate-onBind-onUnbind-onDestory）
服务与启动者相互关联，启动者销毁，服务也跟着销毁；
3）startService之后再bindService这样避免宿主死亡之后service跟着被销毁。

●06.线程间通信有哪些方式
1）接口
2）handler
3）观察者模式（EventBus，RxJava也可以实现）
4）AsyncTask
5）广播BroadCast
6）SharedPreferences

●07.进程间通信有哪些方式
1）intent，访问其他程序的Activity或者调用系统电话，短信。
2）ContentProvider，多个App共享数据
3）AIDL（Android Interface Define Language）服务，客户端定义接口暴露给服务端使用
4）BroadCast
5）Socket

●08.描述一下ANR错误，哪些情况会发生，如何避免？
Activity内事件在5s后依然无响应，broadcastreceiver 10s内无法回应，service 20s内无法处理完成都会导致应用无响应。（在主线程做好事操作都会导致ANR）
避免：
1）不要在主线程做好事操作（数据库查询，网络操作，大量数据存储，图片的切割等）。
2）不要再广播内做耗时操作，如果非要，那么请通过service新启线程来进行耗时操作。

●09.横竖屏切换activity的生命周期
1）不设置manifest里设置Android:configChanges
设置manifest里设置Android:configChanges="orientation"，执行顺序
onSaveInstanceState-onpause-onstop-ondestory-onCreate-onStart-onRestoreInstanceState-onresume
2）设置manifest里设置Android:configChanges="orientation|keyboardHidden"，不会调用生命周期，只会执行onConfigurationChanged方法。

●10.MVC与MVP的区别
1）功能复杂的话，MVC的activity或fragment会很庞大，view与model耦合严重
2）功能复杂的话，MVP会产生很多接口，activity需要很多接口方法来更新UI，model与view不直接进行交互，达到解耦的效果

●11.LRU算法的原理？
LRU（Least Recently Used）最近最少使用，LRU使用的是LinkedHashMap，如果链表中存在一个数则建起置顶，如果没有则直接在顶部加入这个数并将其底部的数移除。

●12.IntentService和Service有什么区别？
1）Service不是独立的进程，也不是独立的线程，他也是依赖于应用程序的主线程，可以说是没有界面的activity，后台执行，不建议在service中编写好事的逻辑和操作，否则会ANR。
2）IntentService是Service的子类，IntentService在执行onCreate操作的时候，内部开了一个线程，去执行耗时操作。通过Handler Looper Message的方式实现了一个多线程的操作，同时耗时操作也可以被这个线程管理和执行，不会产生ANR。
3）其实就是IntentService内部单开了一个线程

●13.调用系统界面时，怎么保存当前activity的状态？
1）为了防止调用系统界面时，当前activity被回收，需要覆写onSaveInstanceState，保存当前的状态变量值。

●14.activity与Fragment之间的通信方式
1）接口（常用）
2）EventBus（观察者模式）
3）Handler（偶尔）
4）广播broadcast（基本不用）

●15.service和线程的区别，我们为什么不用service代替线程，相应在什么情况下使用？
1）
2）
3）
4）
5）
6）

●16.RecyclerView 和 ListView的区别
1）RecyclerView的Viewholder规范化
2）RecyclerView可以实现线性布局，网格布局，瀑布流布局效果
3）ListView具有setEmptyView，addHeaderView，addFooterView
4）RecyclerView支持局部刷新
5）RecyclerView轻松实现item动画效果
6）RecyclerView没有setOnItemClickListener，setOnItemLongClickListener，而是添加了addOnItemTouchListener，可以多次添加事件
7）RecyclerView可以自定义分割线

●17.View的绘制流程
从ViewRoot的performTraversals方法开始依次调用performMeasure、performLayout和performDraw这三个方法。
这三个方法分别完成顶级View的measure、layout和draw三大流程，其中performMeasure会调用measure，measure又会调用onMeasure，在onMeasure中则会对所有子元素进行measure（测量），这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程，接着子元素会重复父容器的measure，如此反复就完成了整个View树的遍历。
同理，performLayout和perforDraw也分别完成performMeasure类似的流程。通过这三大流程，分别遍历正科View树，就实现了Measure，Layout，Draw这一过程，view就绘制出来了。

●18.ArrayList、LinkedList、Vector的区别
1）ArrayList类似于C中的数组，查找方便，插入复杂；
2）LinkedList类似于C中的链表，插入简单（只是把两个item的上下节点换了一下），查找复杂度高；
3）Vector类似于ArrayList，在Java1.5之后就不推荐使用了

●19.Map、Set、List、Queue、Stack的特点与用法。
1）map根据key 找 value。
2）set元素不能重复。
3）list类似数组。
4）Queue队列，先进先出。
5）Stack 栈，后进后出。

●20.HashMap和HashTable的区别（没用过）
1）当需要同步时，用HashTable，反之用HashMap。但是因为在需要时，HashMap可以被同步，HashMap的功能比HashTable的功能更多，而且他不是基于一个陈旧的类，所以有人认为在各种情况下，HashMap都优先于HashTable。
2）只有HashMap可以让你将控制作为key或value。key只能有一个空，不重复，value可以重复。

●21.HashMap和ConCurrentHas和Map的区别，
1）有并发访问的时候用ConcurrentHashMap，效率比用锁的HashMap好。
2）HashMap的底层源码是用（Entry）数组+链表的形式实现，详情看：http://liaokang-java.iteye.com/blog/1098404
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）
