面试题总结

●01.java中equal与==的区别
1）基本数据类型==比较的是值，非基本类型比较的是内存地址
2）Object默认equal比较的是内存地址。可重写其方法，按自己的需求来定义相比较的内容。

●02.handler机制与RaJava有什么区别：相同都是为了线程间通信
1）Rxjava线程切换更方便，可以直接切换子线程和UI线程，handler需要在子线程中发送消息，在主线程中去接收消息，才能改变UI。
2）RxJava是观察者模式，Handler消息队列用的是双向链表，也就是责任链模式。

●03.广播有几种创建方式，有什么区别？
两种，动态注册和静态注册（8.0以后不能静态注册广播，官方说法是为了省电）；区别：
1）动态注册的广播永远要快于静态注册的广播，不管静态注册的优先级设置的多高，不管动态注册的优先级有多低。也就是和设置优先级无关，动态就是比静态快。
2）动态注册广播不是常住性广播，也就是说广播跟随activity的生命周期。注意：activity调用ondestory，移除广播接收器。静态注册是常驻型，不能自动销毁，应用程序关闭后，如有信息广播来，程序也会被系统调用自动运行。
3）在同一个优先级下，谁嫌弃都弄得快，谁将先接收到广播。

●04.Android的数据存储方式有哪些
1）Shardpreferences（适合轻量级数据存储，采用xml键值对的形式存储到本地，只能用于一个app内）
2）文本文件存储（序列化与反序列化）
3）SQLite数据库存储
4）ContentProvider
5）网络存储

●05.服务的启动方式和对应的生命周期以及区别
1）startService（onCreate-（onStart已舍弃）-onStartCommand-onDestory）
服务于启动者没有必然的联系，启动者销毁，服务也可以存在；只有主动调用StopService方法才能停止。
2）bindService（onCreate-onBind-onUnbind-onDestory）
服务与启动者相互关联，启动者销毁，服务也跟着销毁；
3）startService之后再bindService这样避免宿主死亡之后service跟着被销毁。

●06.线程间通信有哪些方式
1）接口
2）handler
3）观察者模式（EventBus，RxJava也可以实现）
4）AsyncTask
5）广播BroadCast
6）SharedPreferences

●07.进程间通信有哪些方式
1）intent，访问其他程序的Activity或者调用系统电话，短信。
2）ContentProvider，多个App共享数据
3）AIDL（Android Interface Define Language）服务，客户端定义接口暴露给服务端使用
4）BroadCast
5）Socket

●08.描述一下ANR错误，哪些情况会发生，如何避免？
Activity内事件在5s后依然无响应，broadcastreceiver 10s内无法回应，service 20s内无法处理完成都会导致应用无响应。（在主线程做好事操作都会导致ANR）
避免：
1）不要在主线程做好事操作（数据库查询，网络操作，大量数据存储，图片的切割等）。
2）不要再广播内做耗时操作，如果非要，那么请通过service新启线程来进行耗时操作。

●09.横竖屏切换activity的生命周期
1）不设置manifest里设置Android:configChanges
设置manifest里设置Android:configChanges="orientation"，执行顺序
onSaveInstanceState-onpause-onstop-ondestory-onCreate-onStart-onRestoreInstanceState-onresume
2）设置manifest里设置Android:configChanges="orientation|keyboardHidden"，不会调用生命周期，只会执行onConfigurationChanged方法。

●10.MVC与MVP的区别
1）功能复杂的话，MVC的activity或fragment会很庞大，view与model耦合严重
2）功能复杂的话，MVP会产生很多接口，activity需要很多接口方法来更新UI，model与view不直接进行交互，达到解耦的效果

●11.LRU算法的原理？
LRU（Least Recently Used）最近最少使用，LRU使用的是LinkedHashMap，如果链表中存在一个数则建起置顶，如果没有则直接在顶部加入这个数并将其底部的数移除。

●12.IntentService和Service有什么区别？
1）Service不是独立的进程，也不是独立的线程，他也是依赖于应用程序的主线程，可以说是没有界面的activity，后台执行，不建议在service中编写好事的逻辑和操作，否则会ANR。
2）IntentService是Service的子类，IntentService在执行onCreate操作的时候，内部开了一个线程，去执行耗时操作。通过Handler Looper Message的方式实现了一个多线程的操作，同时耗时操作也可以被这个线程管理和执行，不会产生ANR。
3）其实就是IntentService内部单开了一个线程

●13.调用系统界面时，怎么保存当前activity的状态？
1）为了防止调用系统界面时，当前activity被回收，需要覆写onSaveInstanceState，保存当前的状态变量值。

●14.activity与Fragment之间的通信方式
1）接口（常用）
2）EventBus（观察者模式）
3）Handler（偶尔）
4）广播broadcast（基本不用）

●15.service和线程的区别，我们为什么不用service代替线程，相应在什么情况下使用？
1）Service是Android的四大组件之一，对应的service是运行在主线程上的，可以说是一个没有显示页面的activity，由系统进程托管。他们之间的通信类似于client和server，是一种轻量级的IPC通信，这种通信的载体是binder，他是在Linux层交换信息的一种IPC
2）线程是程序执行的最小单元，是分配CPU的基本操作。耗时操作一般会开启异步线程来执行。
区别：
3）线程的运行是独立，要么运行结束，要么主动停止。一般一条线程只会在一个activity内生成以及运行，不能被多个activity进行控制。service可以被共用。
4）service也是在主线程上运行，耗时操作会ANR。
5）在应用中，如歌曲播放可以使用service，下载之类的耗时操作使用异步线程。

●16.RecyclerView 和 ListView的区别
1）RecyclerView的Viewholder规范化
2）RecyclerView可以实现线性布局，网格布局，瀑布流布局效果
3）ListView具有setEmptyView，addHeaderView，addFooterView
4）RecyclerView支持局部刷新
5）RecyclerView轻松实现item动画效果
6）RecyclerView没有setOnItemClickListener，setOnItemLongClickListener，而是添加了addOnItemTouchListener，可以多次添加事件
7）RecyclerView可以自定义分割线

●17.View的绘制流程
从ViewRoot的performTraversals方法开始依次调用performMeasure、performLayout和performDraw这三个方法。
这三个方法分别完成顶级View的measure、layout和draw三大流程，其中performMeasure会调用measure，measure又会调用onMeasure，在onMeasure中则会对所有子元素进行measure（测量），这个时候measure流程就从父容器传递到子元素中了，这样就完成了一次measure过程，接着子元素会重复父容器的measure，如此反复就完成了整个View树的遍历。
同理，performLayout和perforDraw也分别完成performMeasure类似的流程。通过这三大流程，分别遍历正科View树，就实现了Measure，Layout，Draw这一过程，view就绘制出来了。

●18.invalidate与requestLayout的区别，以及postInvalidate
1）View不停向上找parent，可以一直找到DecorView，按理说DecorView是顶点了，但是DecorView还有个虚拟父View，ViewRootImpl。ViewRootImpl不是一个View或者ViewGroup，他有个成员没View是DecorView，所有的操作从ViewRootImpl开始自伤而下分发。
2）View的invalidate不会导致ViewRootImplement的invalidate被调用，而是递归调用父View的invalidateChildInparent，知道ViewRootImpl的invalidateChildInParent，然后出发performTraversals，会导致当前View被重绘，由于mLayoutRequested为false，不会导致onMeasure和onLayout被调用，而onDraw会被调用。
3）一个View的invalidate会导致本身PFLAG_INVALIDATED的值变为1，导致本身以及父族ViewGroup的PFLAG_DRAWING_CACHE_VALID变成0.
4）requestLayout会直接递归调用父窗口的requestLayout，知道ViewRootImpl，然后除服perforTraversals，由于mLayoutRequested为true，会导致onMeasure和onLayout被调用，不一定会触发onDraw。
5）requestLayout触发onDraw应该是在layout过程中发现l,t,r,b和以前不一样，那就触发一次invalidate，所以出发了onDraw，也可能是因为别的原因导致mDirty非空（比如在跑动画）
6）requestLayout会导致自己以及父族View的PFLAG_FORCE_LAYOUT和FLAG_INVALIDATED标志被设置。

7）invalidate是在UI线程自身中使用，要在异步线程中使用需要通过handler等消息通知UI主线程，在UI主线程中调用invalidate。
8）postInvalidate主要是在非UI主线程中使用，刷新主线程UI；当然主线程作为一个线程，用也没有毛病。

9）一般来说，主线程中刷新调用invalidate，异步使用postInvalidate；需要重新测量measure就调用requestLayout，为保证重绘就跟着调用个invalidate。

●19.ArrayList、LinkedList、Vector的区别
1）ArrayList类似于C中的数组，查找方便，插入复杂；
2）LinkedList类似于C中的链表，插入简单（只是把两个item的上下节点换了一下），查找复杂度高；
3）Vector类似于ArrayList，在Java1.5之后就不推荐使用了

●20.Map、Set、List、Queue、Stack的特点与用法。
1）map根据key 找 value。
2）set元素不能重复。
3）list类似数组。
4）Queue队列，先进先出。
5）Stack 栈，后进后出。

●21.HashMap和HashTable的区别（没用过）
1）当需要同步时，用HashTable，反之用HashMap。但是因为在需要时，HashMap可以被同步，HashMap的功能比HashTable的功能更多，而且他不是基于一个陈旧的类，所以有人认为在各种情况下，HashMap都优先于HashTable。
2）只有HashMap可以让你将控制作为key或value。key只能有一个空，不重复，value可以重复。

●22.HashMap和ConCurrentHas和Map的区别，
1）有并发访问的时候用ConcurrentHashMap，效率比用锁的HashMap好。
2）HashMap的底层源码是用（Entry）数组+链表的形式实现，详情看：http://liaokang-java.iteye.com/blog/1098404


●23.TreeMap、HashMap、LinkedHashMap的区别。
1）LinkedHashMap也是一个HashMap，但是内部维持了一个双向链表可以保持顺序。
2）TreeMap可以用于排序（根据键排序，默认是升序）。
3）HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的，只不过Set用的只是Map的key，Map的key和Set都有一个共同的特性就是集合的唯一性。TreeMap只是多了一个排序的功能。

●24.Collection包结构与Collections的区别？
1）Collection--list--ArrayList，LinkedList，Vector
2）Set--HashSet，TreeSet
3）Map--HashMap，TreeMap，HashTable
4）Collection是集合类的上级接口，子接口主要有Set和List、Map。
5）Collections是针对集合类的一个帮助类，提供了操作集合的工具方法：一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。

●25.try...catch...finally，如果try里有return，finally还执行吗？
答：必须执行，如果try里有，finally里也有，也会执行finally中的return。

●26.override和overload含义的区别
1）override是重写父类的函数，可以用super继承原有的方法结构，并重写属于自己的代码
2）overload是函数重载，根据传入参数的个数，类型不同来区分。dart语言不支持重载，需要不同的名称。

●27.interface与abstract类的区别？
1）interface是接口，可以有常量，所有方法都默认是public，且不能实现。
2）abstract类，只是不其他普通类多了个抽象方法，且必须有抽象方法。

●28.static class与非静态的区别？
1）静态内部类不需要有只想外部类的引用，非静态内部类可以持有对外部类的引用。
2）非静态内部类能够访问外部类的静态和非静态成员；静态类不能访问外部类的非静态成员，他只能访问外部类的静态成员。
3）单例模式可以用静态内部类的方式来实现。
4）静态内部类的加载不需要依附外部类，在使用时才加载，不过在加载静态内部类的过程中也会加载外部类。

●29.线程同步的方法：synchronized、lock、reentrantLock等
1）Lock.lock()加锁，lock.unlock()释放锁
2）reentrantLock，可重入锁。
3）synchronized只有单一条件，不能设置加锁时间等，也不能设置多个锁。

●30.wait和sleep的区别
1）sleep不能释放同步锁，wait释放同步锁
2）sleep是Thread类的方法，wait是object的方法，wait，notify，notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。

●31.反射的作用与原理
指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并声称其对象实体、或对其fields设值、或唤起其methods。
用途：Java反射机制主要提供了一下功能：
1）在运行时判断任意一个对象所属的类；
2）在运行时构造任意一个类的对象；
3）在运行时判断任意一个类所具有的成员变量和方法；
4）在运行时调用任意一个对象的方法；
5）生成动态代理。

●32.进程与线程的区别。
县城作为跳读和分配的基本单位，进程作为拥有资源的基本单位。

●33.思索的必要条件，怎么处理死锁。
1）循环等待
2）非抢占
3）互斥使用
4）占有并等待。
处理方法：
死锁避免--银行家算法：包含资源请求算法和安全性算法，死锁检测算法。

●34.IPC的几种通信方式
共享内存、消息传递、管道、信号量

●35.TCP的三次握手与四次挥手
1）开始连接：客户端请求server连接，server发送响应码，客户端告诉server已匹配。
2）开始传输数据。
3）客户端告诉server请求断开连接，server发送两次回执，客户端与server断开

●36.thread与runnable的区别
1）Thread继承自runnable，一个类对应一个run方法。
2）实现runnable接口比继承Thread更灵活，适合多个相同程序代码的线程去处理同一个资源，也就是共同拥有同一个run方法。
3）可以避免Java中的单继承的限制。
4）增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。

5）就算Thread的run方法加上synchronized，但是创建的是两个对象，也就是两个锁，两个锁会交替争抢CPU资源，谁抢到谁执行；没有锁也是一样，所以可以不加锁。
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）

●.
1）
2）
3）
4）
5）
6）
1.跨进程通信的几种方式

Intent,比如拨打电话
ContentProvider数据库存储数据
Broadcast广播通信
AIDL通信，通过接口共享数据
2.wait和sleep 的区别

wait是Object的方法，wait是对象锁，锁定方法不让继续执行，当执行notify方法后就会继续执行，sellp是Thread的方法，sellp是使线程睡眠，让出cpu，结束后自动继续执行
3.String,StringBuffer,StringBuilder的区别

String不可改变对象，一旦创建就不能修改
String str="aaa";
str="bbb";

以上代码虽然改变了str，但是执行过程是回收str，把值赋给一个新的str
StringBuffer创建之后，可以去修改
StringBuilder也可修改，执行效率高于StringBuffer，不安全
当字符赋值少使用String
字符赋值频繁使用StringBuilder
当多个线程同步操作数据，使用StringBuffer
4.View和SurfaceView的区别

View基于主线程刷新UI，SurfaceView子线程又可以刷新UI
5.View的绘制原理

View为所有图形控件的基类，View的绘制由3个函数完成
measure,计算视图的大小
layout,提供视图要显示的位置
draw,绘制
6.简述JNI

是java和c语言之间的桥梁，由于java是一种半解释语言，可以被反编译出来，一种重要涉及安全的代码就使用了C编程，再者很多底层功能调用C语言都实现了Java没必要重复造轮子，所以定义了JNI接口的实现
7.简述TCP，UDP，Socket

TCP是经过3次握手，4次挥手完成一串数据的传送
UDP是无连接的，知道IP地址和端口号，向其发送数据即可，不管数据是否发送成功
Socket是一种不同计算机，实时连接，比如说传送文件，即时通讯
8.音视频相关类

总体来说，分为几个类
视频录制方面，Camear摄像头录制视频类，MediaProjection屏幕录制视频类
编码方面，MediaCodec，MediaRecorder
预览方面，SurfaceView,GLSurfaceView,TextureView,VideoView
9.进程和线程的区别

概念：进程包括多个线程，一个程序一个进程，多线程的优点可以提高执行效率，提高资源利用率
创建：Thread类和Runnable接口，
常用方法有：
start()用于启动线程
run()调用线程对象中的run方法
join()合并插队到当前线程
sellp()睡眠释放cpu资源
setPriority()设置线程优先级
10.内存泄露如何查看和解决

概念：有些对象只有有限的生命周期，当他们的任务完成之后，它们将被垃圾回收，如果在对象的生命周期本该结束的时候，这个对象还被一系列的引用，着就会导致内存泄露。
解决方法：使用开源框架LeakCanary检测针对性解决
常见的内存泄露有：
单例造成的内存泄露，例如单例中的Context生命周期大于本身Context生命周期
线程使用Hander造成的内存卸扣，当activity已经结束，线程依然在运行更新UI
非静态类使用静态变量导致无法回收释放造成泄露
WebView网页过多造成内存泄露
资源未关闭造成泄露，例如数据库使用完之后关闭连接
11.View的分发机制，滑动冲突

View的事件传递顺序有3个重要的方法，dispatchTouchEvent()是否消耗了本次事件，onInterceptTouchEvent()是否拦截了本次事件，onTouchEvent()是否处理本次事件，滑动冲突分为同方向滑动冲突，例如ScrollView和ListView，同方向滑动冲突，可以计算ListView高度而动态设置ListView的高度，ScrollView高度可变。例如ViewPager和ListView,不同方向滑动冲突，一个是横向滑动一个是竖直滑动，不同方向滑动可以判断滑动的x，y轴是横向还是竖直滑动，如果判断得到是横向滑动，就拦截ListView的事件，竖则反之。
12.RecyclerView和ListView的区别

缓存上:前者缓存的是View+ViewHolder+flag，不用每次调用findViewById,后者则只是缓存View
刷新数据方面，前者提供了局部刷新，后者则全部刷新
13.recyclerView嵌套卡顿解决如何解决

设置预加载的数量LinearLayoutManager.setInitialPrefetchItemCount(4)，默认是预加载2个，
设置子项缓存，
设置自带滑动冲突解决属性rv.setHasFixedSize(true); rv.setNestedScrollingEnabled(false);
可以完美解决，不过Google不推荐RecyClerView嵌套使用,需要嵌套尽量找类似于ExpandableListView 第三方控件来解决
14，谈MVC ，MVP，MVVM

MVC:View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些 业务逻辑。 在MVC模型里，更关注的Model的不变，而同时有多个对Model的不同显示，及View。所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。
MVP：MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负 责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会从直接Model中读取数据而不是通过 Controller。
MVVM：数据双向绑定，通过数据驱动UI，M提供数据，V视图，VM即数据驱动层
15.dagger2

Dagger2是一个主要用于依赖注入的框架，减少初始化对象操作，降低耦合度
16Android性能优化

布局优化: 减少布局层级，使用ViewStub提高显示速度，布局服用，尽可能少使用warp_content，删除空间中无用的属性,避免过度绘制移除window默认背景，按需显示展位图，自定义View优化，使用canvas.clipRect()识别可见区域
启动速度:采用分布加载，异步加载，延期加载提高应用初始化速度，采用线程初始化数据等，合理的刷新机制
内存方面:防止内存泄露,使用一些第三方工具检测解决
代码优化:遵循Java生命周期
安装包优化:删除无用资源，优化图片，代码混淆，避免重复库存在，插件化
17.Hander原理

Handler，loop轮询检测发送消息到MessagerQuery,MessageQuery对Message入列，Handler回调方法处理消息，重写handMessage方法刷新ui
18.SharedPreference跨进程使用会怎么样？如何保证跨进程使用安全？

在两个应用的manifest配置中好相同的shartdUserId属性，A应用正常保存数据，B应用
createPackageContext("com.netease.nim.demo", CONTEXT_IGNORE_SECURITY)
获取context然后获取应用数据，为保证数据安全，使用加密存储
19.推送到达率如何提高

判手机系统，小米使用小米推送，华为使用华为推送，其他手机使用友盟推送
20.activity，fragment传值问题

通过Bundle传值，在activty定义变量传值，扩展fragment创建传值
