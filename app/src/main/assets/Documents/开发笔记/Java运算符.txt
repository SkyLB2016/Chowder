Java 运算符
算术运算符
关系运算符
位运算符
逻辑运算符
赋值运算符
条件运算符
其他运算符

1）算术运算符：7个；
+ 	加法 - 相加运算符两侧的值
- 	减法 - 左操作数减去右操作数
* 	乘法 - 相乘操作符两侧的值
/ 	除法 - 左操作数除以右操作数
％ 	取余 - 左操作数除以右操作数的余数
++ 	自增 - 操作数的值增加1
-- 	自减 - 操作数的值减少1

2）关系运算符：6个；
== 检查如果两个操作数的值是否相等，如果相等则条件为真。
!= 检查如果两个操作数的值是否相等，如果值不相等则条件为真。
> 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。
< 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。
>= 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。
<= 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。

3）位运算符：二进制运算符，7个，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。
位运算符作用在所有的位上，并且按位运算。
假设A = 60，和B = 13;它们的二进制格式表示将如下：
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A | B = 0011 1101
A ^ B = 0011 0001
~A= 1100 0011
下表列出了位运算符的基本运算,假设整数变量A的值为60和变量B的值为13：

＆ 按位与操作符，两位全为1，结果才为1；相当于取交集（既属于A，又属于B）。
0 & 0 = 0；
1 & 0 = 0；
0 & 1 = 0；
1 & 1 = 1；
例：
A&B 即

0011 1100
&
0000 1101
=
0000 1100

得到12；

特殊用法：
（1）清零，如果想将一个单元清零，也就是全部二进制位为0，那就与0相交。
（2）取出一个数中指定的位数，在对应位数与1相交，1&1=1；0&1=0；所以就可以取出对应位置的对应数据。
例如 MeasureSpec中取size与mode时
private static final int MODE_SHIFT = 30;//位移的位数
private static final int MODE_MASK = 0x3 << MODE_SHIFT;
取正二进制为： MODE_MASK ==11000000000000000000000000000000
取反二进制为：~MODE_MASK ==00111111111111111111111111111111

public static final int UNSPECIFIED = 0 << MODE_SHIFT;
二进制为：UNSPECIFIED ==0，0左移多少位都是0

public static final int EXACTLY = 1 << MODE_SHIFT;
二进制为：EXACTLY ==01000000000000000000000000000000；位置在第31位上
public static final int AT_MOST = 2 << MODE_SHIFT;
二进制为：AT_MOST ==10000000000000000000000000000000；位置在第32位上

public static int makeMeasureSpec(int size, int mode) {
    if (sUseBrokenMakeMeasureSpec) {
        return size + mode;
    } else {
        return (size & ~MODE_MASK) | (mode & MODE_MASK);
    }
}
假设size为60，即 0011 1100
mode为 AT_MOST，

size & ~MODE_MASK
=
0000 0000 0000 0000 0000 0000 0011 1100
&
0011 1111 1111 1111 1111 1111 1111 1111
=
0000 0000 0000 0000 0000 0000 0011 1100


mode & MODE_MASK
=
1000 0000 0000 0000 0000 0000 0000 0000
&
1100 0000 0000 0000 0000 0000 0000 0000
=
1000 0000 0000 0000 0000 0000 0000 0000

(size & ~MODE_MASK) | (mode & MODE_MASK)
=
0000 0000 0000 0000 0000 0000 0011 1100
|
1000 0000 0000 0000 0000 0000 0000 0000
=
1000 0000 0000 0000 0000 0000 0011 1100


public static int getMode(int measureSpec){
    return measureSpec & MODE_MASK;
}

measureSpec & MODE_MASK
=
1000 0000 0000 0000 0000 0000 0011 1100
&
1100 0000 0000 0000 0000 0000 0000 0000
=
1000 0000 0000 0000 0000 0000 0000 0000

public static int getSize(int measureSpec){
    return measureSpec & ~MODE_MASK;
}
measureSpec & ~MODE_MASK;
=
1000 0000 0000 0000 0000 0000 0011 1100
&
0011 1111 1111 1111 1111 1111 1111 1111
=
0000 0000 0000 0000 0000 0000 0011 1100


| 按位或操作符，一个为1，结果就为1；相当于取并集（AB合在一起）。
0 | 0 = 0；
1 | 0 = 1；
0 | 1 = 1；
1 | 1 = 1；
例：
A | B 即

0011 1100
|
0000 1101
=
0011 1101

得到61；

特殊用法：
对一个数据的某些位置设置值为1，因为0|1=1；

^ 按位异或操作符，相同位置上的数据，相同是0，不相同是1；相当于取补集（刨除交集之外的就是补集，也就是相同的剔除，不同的留下）；
A ^ B

0011 1100
^
0000 1101
=
0011 0001

得到49;
特殊用法
（1）与1相异或，使特定位翻转
（1）与0相异或，就是保留原值；

〜 取反与操作符，翻转二进制的每一位，即0变1，1变0；
〜A

~0011 1100
=
11111111111111111111111111000011

<< n	按位左移运算符。左操作数按位左移右操作数指定的位数。 	A << 2得到240，即 1111 0000 ，相当于A*2的2次方
>> 	按位右移运算符。左操作数按位右移右操作数指定的位数。 	A >> 2得到15即 1111 ，相当于A除以2的2次方
>>>	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 	A>>>2得到15即0000 1111

4）逻辑运算符
&& 	短路与，称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 	（A && B）为假。
|| 	称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 	（A | | B）为真。
！ 	称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 	！（A && B）为真。

5）赋值运算符
= 	简单的赋值运算符，将右操作数的值赋给左侧操作数 	C = A + B将把A + B得到的值赋给C
+= 	加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数 	C + = A等价于C = C + A
-= 	减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数 	C - = A等价于C = C - A
*= 	乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数 	C * = A等价于C = C * A
/= 	除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数 	C / = A等价于C = C / A
％= 	取余和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 	C％= A等价于C = C％A
<<=	左移位赋值运算符 	C << = 2等价于C = C << 2
>>=	右移位赋值运算符 	C >> = 2等价于C = C >> 2
＆= 	按位与赋值运算符 	C＆= 2等价于C = C＆2
^= 	按位异或赋值操作符 	C ^ = 2等价于C = C ^ 2
|= 	按位或赋值操作符 	C | = 2等价于C = C | 2

6）条件运算符（?:）；也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。

7）instanceOf 运算符，该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。