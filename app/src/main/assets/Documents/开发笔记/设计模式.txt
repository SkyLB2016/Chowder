设计模式

●01.面向对象的六大原则
1）单一职责原则(Single Responsibility Principle)：重要
一个类只负责一项职责；
2）开闭原则（Open Close Principle）：重要
对扩展开放，对修改关闭；
让程序更稳定，更灵活；依赖于抽象，独立于实现。在文件来说就是隐藏实现private，暴露调用方法public。
3）里氏代换原则（Liskov Substitution Principle）：
子类可以扩展父类的功能，但不要改变父类原有的功能。
构建扩展性更好的系统；核心依然依赖于抽象，拆分出共同的实现方法，单独编写不同的实现，依赖于面向对象三大特性中的继承与多态。
4）依赖倒转原则（Dependence Inversion Principle）：重要
面向接口编程；
让项目拥有变化的能力；模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，依赖于三大特性中的多态。
5）接口隔离原则（Interface Segregation Principle）：
设计接口功能尽量细化；最小功能单元。
系统拥有更高的灵活性；接口中方法的拆分，实现类只需要继承自己需要的接口
6）迪米特法则（最少知道原则）（Demeter Principle）：
降低耦合，局部变量中不要引入新的类。？？局部的话，内存回收不是更快吗？
更好的扩展性；类似于MVP，单一指向；

●02.设计模式的分类
总体来说设计模式分为三大类：
1）创建型模式，共五种：
单例模式、建造者模式、原型模式、工厂模式、抽象工厂模式。
2）行为型模式，共十一种：
父类与子类：一个方法不同的实现，公共方法的提取形成的两种模式：策略模式、模板方法模式；适用于算法的改变。
两个类之间：观察者模式、迭代子模式(数组迭代器)、责任链模式（handler的循环链）、命令模式（相当于逐级传递）。
类的状态：备忘录模式（备份模式）、状态模式（状态的切换，卫星菜单栏）。
通过中间类：访问者模式、中介者模式、解释器模式。
3）结构型模式，共七种：
适配器模式：类（在MVP中用过，类似于两类重用一个方法）、对象（在一个类里的一个方法中调用另一个类里的相同方法）、接口（三种适配器模式）；
（后六种是对象适配器的衍生）：
装饰器模式（同接口间两个类的操作）->代理模式（与装饰器基本相同，细微差别具体分析）->外观模式（相当于类的组合排序）；
桥接模式（公共管理器，动态替换其中的对象）->组合模式（地址选择中有运用，有点类似于linked）->享元模式（一般结合工厂模式，jdbc连接池）。
4）其实还有两类：并发型模式和线程池模式。

正文

●01.工厂模式：Factory Pattern
解释：应用最广泛的模式，产品接口，多个实现类，工厂接口，对应的多个工厂实现类，调用对应的工厂。
工厂模式由于有过多的工厂类，所以对于简单的应用还是直接使用静态工厂最好，复杂的就用抽象工厂模式。
简单（静态）工厂模式就是只有一个工厂的模式：产品接口，多个实现类，工厂，调用。
1）Iterable接口等等

●02.抽象工厂模式：Abstract Factory Pattern
解释：多个产品接口，产品实现类，组合工厂接口，实现类工厂，调用。
1）MediaPlayer的创建
工厂与抽象工厂的对比：
1.工厂模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂模式的推广。
2.工厂模式用来创建一个产品的等级结构，而抽象工厂模式是用来创建多个产品的等级结构。
3.工厂模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。

●03.建造者模式 Builder：
解释：二次封装，犹如三层楼，第一层设置参数，第二层通过build再次复制参数，第三层开始使用。只有一层的话，当第一层发生变化，使用时也就发生了变化，所以需要加入第二层，只要不执行build创建，第一层可以随便改。
1）dialog的创建
2）WindowManager

●01.单例模式:singleton
解释：应用最广的模式，几种模式实现方式：
1）饿汉模式：第一次加载时就初始化，如果不使用的话是一种资源的浪费，系统内使用的就是这种，所以也推荐使用。
2）懒汉模式（synchronized修饰方法）：第一次使用时才初始化，但是每次使用时，必须同步，一样会造成资源的浪费
3）双重检索模式：已不推荐使用
4）静态内部类模式：即实现了线程安全，又避免了同步带来的性能影响，推荐使用的
5）枚举模式：线程安全，反序列化不生成新实例。推荐使用
6）单例容器，统一调配使用。系统服务的获取就是单例容器的应用
7）LayoutInflater

●03.原型模式
解释：浅复制与深复制，当对象中的属性都为八种基本类型时，浅复制即可；其他引用类型需用深复制才能拷贝一份独立的对象。
1）Intent，Array的clone
2）由于clone()方法是protected修饰的，因此自定义model需要实现Cloneable接口，同时需要覆写clone()方法才能调用。


●06.策略模式
解释：工厂模式的变种，一种产品的多种实现，工厂与调用结合依赖于抽象产品（多态）（OCP与DIP原则）
1）动画的实现应用了策略模式
2）自定义的日历选择使用了策略模式。

●07.状态模式
解释：此模式模式和策略模式基本相同，但应用场景不同，适用于状态改变后，之后的操作都不一样。
1）WiFi的模式
2）登录的状态改变

●08.责任链模式：Iterator Pattern
解释：一个事件，依次逐级传递，最后被某一级对象所处理，则为纯责任链，如最终都没有处理，则为不纯。
1）触摸事件的分发
2）handler
3）用广播也可以实现责任链模式。

●09.解释器模式（懵逼中）
解释：Interpreter Pattern，使用较少，（目前我对此比较懵逼）。
1）计算器可以使用解释器来写

●10.命令模式（同样有点懵逼中）
解释：Command Pattern，接收者（执行者），命令者，请求者，客户端（）。
1）android的输入事件

●11.观察者模式
解释：对象解耦；一个对象改变，所有依赖于他的对象都会得到通知。类似于责任链的串行（线性）传递，转成并行传递，相当于一个是串行，一个是并行。
1）adapter适配器
2）BroadcastReceiver
3）事件总线

●12.备忘录模式：Originator
解释：（被保存的对象）创建备忘录Memoto；Memoto需要存取的属性值，Caretaker保存和读取Memoto。
1）activity被杀死时备份
2）游戏存档

●13.迭代器模式：Iterator，也叫游标模式Cursor。
1）Iterator迭代器，iterator与iterable联合使用
2）数据库中的游标

●14.模板方法模式
1）
2）
3）

●15
1）
2）
3）
