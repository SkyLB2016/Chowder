设计模式

●01.面向对象的六大原则
(1)单一职责原则(Single Responsibility Principle)：不同功能间拆分成独立的类（与接口隔离原则相类似，都是大类的细化拆分）
(2)开闭原则（Open Close Principle）：让程序更稳定，更灵活；依赖于抽象，独立于实现。在文件来说就是隐藏实现private，暴露调用方法public。
(3)里氏代换原则（Liskov Substitution Principle）：构建扩展性更好的系统；核心依然依赖于抽象，拆分出共同的实现方法，单独编写不同的实现，依赖于面向对象三大特性中的继承与多态。
(4)依赖倒转原则（Dependence Inversion Principle）：让项目拥有变化的能力；模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，依赖于三大特性中的多态。
(5)接口隔离原则（Interface Segregation Principle）：系统拥有更高的灵活性；接口中方法的拆分，实现类只需要继承自己需要的接口
(6)迪米特法则（最少知道原则）（Demeter Principle）：更好的扩展性；类似于MVP，单一指向

●02.设计模式的分类
总体来说设计模式分为三大类：
(1)创建型模式，共五种：
单例模式、建造者模式、原型模式、工厂模式、抽象工厂模式。
(2)行为型模式，共十一种：
父类与子类：一个方法不同的实现，公共方法的提取形成的两种模式：策略模式、模板方法模式；适用于算法的改变。
两个类之间：观察者模式、迭代子模式(数组迭代器)、责任链模式（handler的循环链）、命令模式（相当于逐级传递）。
类的状态：备忘录模式（备份模式）、状态模式（状态的切换，卫星菜单栏）。
通过中间类：访问者模式、中介者模式、解释器模式。
(3)结构型模式，共七种：
适配器模式：类（在MVP中用过，类似于两类重用一个方法）、对象（在一个类里的一个方法中调用另一个类里的相同方法）、接口（三种适配器模式）；
（后六种是对象适配器的衍生）：
装饰器模式（同接口间两个类的操作）->代理模式（与装饰器基本相同，细微差别具体分析）->外观模式（相当于类的组合排序）；
桥接模式（公共管理器，动态替换其中的对象）->组合模式（地址选择中有运用，有点类似于linked）->享元模式（一般结合工厂模式，jdbc连接池）。
(4)其实还有两类：并发型模式和线程池模式。

●03.单例模式:singleton
解释：应用最广的模式，几种模式实现方式：
(1)饿汉模式：第一次加载时就初始化，如果不使用的话是一种资源的浪费
(2)懒汉模式（synchronized修饰方法）：第一次使用时才初始化，但是每次使用时，必须同步，一样会造成资源的浪费
(3)双重检索模式：目前使用最多的，但是在高并发的环境下有一定缺陷。
(4)静态内部类模式：即实现了线程安全，又避免了同步带来的性能影响，推荐使用的
(5)枚举模式：线程安全，反序列化不生成新实例。
(6)单例容器，统一调配使用。系统服务的获取就是单例容器的应用
(7)LayoutInflater

●04.建造者模式 Builder：
解释：二次封装，犹如三层楼，第一层设置参数，第二层通过build再次复制参数，第三层开始使用。只有一层的话，当第一层发生变化，使用时也就发生了变化，所以需要加入第二层，只要不执行build创建，第一层可以随便改。
(1)dialog的创建
(2)WindowManager

●05.原型模式
解释：浅复制与深复制，当对象中的属性都为八种基本类型时，浅复制即可；其他引用类型需用深复制才能拷贝一份独立的对象。
(1)Intent，Array的clone

●06.工厂模式：Factory Pattern
解释：应用最广泛的模式，只存在一个工厂类的时候可以写成静态工厂模式。抽象产品接口，产品实现类，工厂，调用。
(1)Iterable接口等等

●07.抽象工厂模式：Abstract Factory Pattern
解释：抽象产品接口，产品实现类，抽象工厂（内含生成产品的抽象方法），实现类工厂，调用。
(1)MediaPlayer的创建
工厂与抽象工厂的对比：
1.工厂模式是一种极端情况的抽象工厂模式，而抽象工厂模式可以看成是工厂模式的推广。
2.工厂模式用来创建一个产品的等级结构，而抽象工厂模式是用来创建多个产品的等级结构。
3.工厂模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类。

●08.策略模式
解释：工厂模式的变种，一种产品的多种实现，工厂与调用结合依赖于抽象产品（多态）（OCP与DIP原则）
(1)动画的实现应用了策略模式

●09.状态模式
解释：此模式模式和策略模式基本相同，但应用场景不同，适用于状态改变后，之后的操作都不一样。
(1)WiFi的模式
(2)登录的状态改变

●10.责任链模式：Iterator Pattern
解释：一个事件，依次逐级传递，最后被某一级对象所处理，则为纯责任链，如最终都没有处理，则为不纯。
(1)触摸事件的分发
(2)handler
(3)用广播也可以实现责任链模式。

●11.解释器模式（懵逼中）
解释：Interpreter Pattern，使用较少，（目前我对此比较懵逼）。
(1)计算器可以使用解释器来写

●12.命令模式（同样有点懵逼中）
解释：Command Pattern，接收者（执行者），命令者，请求者，客户端（）。
(1)android的输入事件

●13.观察者模式
解释：对象解耦；一个对象改变，所有依赖于他的对象都会得到通知。类似于责任链的串行（线性）传递，转成并行传递，相当于一个是串行，一个是并行。
(1)adapter适配器
(2)BroadcastReceiver
(3)事件总线

●14.备忘录模式：Originator
解释：（被保存的对象）创建备忘录Memoto；Memoto需要存取的属性值，Caretaker保存和读取Memoto。
(1)activity被杀死时备份
(2)游戏存档

●15.迭代器模式：Iterator，也叫游标模式Cursor。
(1)Iterator迭代器，iterator与iterable联合使用
(2)数据库中的游标

●16.模板方法模式
(1)
(2)
(3)

●.
(1)
(2)
(3)
