数据结构与算法

1）冒泡排序：选定一端，两个for循环，两相比较，顺序错误则交换。
2）选择排序：每次选出最大或最小的放在队首，直到完成。
3）插入排序：排序头两个数据，然后每次增加一个数据来循环，直到完成。

●01.数据项，数据元素，数据对象，数据，数据结构 的概念
1）数据项：一个数据元素可以由若干数据项组成。也可以称为字段、域、属性
2）数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录、元素、节点、顶点。
3）数据对象：有相同性质的数据元素的集合，是数据的子集。
4）数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入个计算机处理的符号集合。数据不仅仅包括整形，实形等数值类型，还包括字符及声音、图像、视频等废树脂类型。
5）数据结构：是互相之间存在一种或多种特定关系的数据元素的集合。
ArrayList 就是一个数据结构，里边的数组array就是数据对象

扩展：
数据 == N个数据对象（N个不同类型的List列表里的array）
一个数据对象 == N个同类型的数据元素（list里array中的元素）
一个数据元素 == N个数据元素 + N个数据项，java类与对象
数据项是数据不可分割的最小单位。

数据元素可以包含数据元素（此数据元素内也包含数据项）和 数据项。树形结构，叶子节点

●02.逻辑结构：值数据对象中数据元素之间的相互关系；
1）集合结构：就是放在一起而已，无序
2）线性结构：有序排列
3）树形结构：
4）图形结构：各个元素相关联

●03.物理结构：是指数据的逻辑结构在计算机中的存储形式。
1）顺序存储结构
2）链式存储结构

●04.
1）线性表：多个元素的有序排列的有限序列。
2）队列：只允许在一端插入，在另一端进行删除操作的线性表
3）堆栈：栈是只有一端进行插入和删除操作的线性表
4）树：是n个节点的有续集。节点可以像树一样。叶子节点间没有交集。
5）图论：由顶点的又穷空集合和顶点之间边的集合组成
6）排序算法：对数据进行顺序排列
6）查找算法：在大量数据中寻找我们需要的数据的过程。

●05.数组
1）最简单的数据局结构
2）占据连续内存：数组空间连续，按照申请的顺序存储，但是必须制定数组大小。
3）数组空间效率低：数组中机场有空闲的区域没有得到充分的应用。
4）操作麻烦：数组的中间增加和删除操作很麻烦。
5）

●07.线性表：多个元素有序排列的有限序列。
顺序表: ArrayList，物理结构为顺序存储结构
1）add
2）remove：可以是位置，也可以是对象
3）set(index,E)：修改指定位置的值
4）get
优点：尾部插入效率高，支持随机访问
缺点：中间插入或者删除效率低，

什么情况下不要用ArrayList
涉及到插入和删除的操作不要用。

在ArrayList中间增加删除为什么效率低？
因为增加和删除时会复制这个位置之后的item，前进或者后退一位。

链表：物理结构为链式存储结构。
特点是：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
单链表：内含自身元素，与下一个节点。HashMap
双链表：内含自身元素，以及上下两个节点。LinkedList

顺序表：
优点：
存储空间连续，允许随机访问，尾插，尾删方便。
缺点：
中间插入和删除效率低，长度固定，造成空间浪费。

单链表：
优点：
随意进行增删改，插入删除效率高，长度可以随意修改。
缺点：
内存不连续，不能随机查找，只能从头部开始一个一个往下找，所以效率慢。

双链表：
优点：
随意进行增删改，插入删除效率高，长度可以随意修改，查找效率比单链表快。
缺点：
内存不连续，不能随机查找，只是双链表可以判断查找的位置离头尾的距离，然后开始找，所以比单链表快。

LRU算法
CPU缓存：位于CPU与内存之间的临时存储器。解决CPU速度和内存速度的速度差异问题。
●01.内存淘汰机制
1）FIFO (First In,First Out)先进的先被淘汰掉。
2）LFU (Least Frequently Used) 最不常用的淘汰掉
3）LRU (Least Recently Used) 最近最少使用的淘汰掉
4）
5）

●02.LRU算法的原理，或者说实现
此版本基于Android10.0或者Androidx.collection 1.1.0版本。各版本代码稍有不同，但基本思想就是这样的。
1）新建LRU对象，设置可使用的最大内存缓存maxSize。此时LRU的构造方法中会初始化一个 LinkedHashMap ，并把map的 AccessOrder 属性设为true，用来重排序。
2）put对象时，计算缓存size，map的put方法是在HashMap中实现的，分两种情况：
1、新添加的key，put 完成后会返回null，期间会调用 afterNodeInsertion （判断是否移除队首 head）不用管此方法。
2、key已存在，put 执行时会调用 afterNodeAccess(e) （判断头尾，并设置尾部）把当前替换的节点node移动到队尾，如果已在队尾，就跳出；然后会返回被替换的对象，再次计算size，并在 entryRemoved(false, key, previous, value) 方法中返回（可重写）；
最后和maxSize作比较，是否超限，超限移除head。
3）get对象时，value为空返回null，可以重写 create(key) 方法，自定义一个对象，这之后就是put的流程了。不为空，直接返回该value，同时会在map中调用 afterNodeAccess(e) 把对象移动到队尾。
4）remove对象时，map移除对象，计算当前内存size，在entryRemoved中返回移除的对象，
5）resize(int maxSize) 设置缓存的大小。

●03.LinkedhashMap
1）队尾添加，队首移除，双链表结构，继承自HashMap；但HashMap是单链表；
2）LinkedHashMap继承了HashMap的Node,并自定义了before和after两个字段；
3）内部通过 accessOrder 属性来控制 afterNodeAccess(e) 方法的执行，默认为false，也就是不执行；这个方法是每次都会把put（key存在，替换时）或get的node节点移到队尾。


●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）
