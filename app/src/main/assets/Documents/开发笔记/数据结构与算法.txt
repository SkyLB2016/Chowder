数据结构与算法

1）冒泡排序：选定一端，两个for循环，两相比较，顺序错误则交换。
2）选择排序：每次选出最大或最小的放在队首，直到完成。
3）插入排序：排序头两个数据，然后每次增加一个数据来循环，直到完成。

●01.数据项，数据元素，数据对象，数据，数据结构 的概念
1）数据项：一个数据元素可以由若干数据项组成。也可以称为字段、域、属性
2）数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录、元素、结点、顶点。
3）数据对象：有相同性质的数据元素的集合，是数据的子集。
4）数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入个计算机处理的符号集合。数据不仅仅包括整形，实形等数值类型，还包括字符及声音、图像、视频等废树脂类型。
数据总体指的是计算机中的所有数据集合，而咱们一般说的数据指的是一条，一组数据。

5）数据结构：是互相之间存在一种或多种特定关系的数据元素的集合。
ArrayList 就是一个数据结构，里边的数组array就是数据对象

扩展：
数据 == N个数据对象（N个不同类型的List列表里的array）
一个数据对象 == N个同类型的数据元素（list里array中的元素）
一个数据元素 == N个数据元素 + N个数据项，java类与对象
数据项是数据不可分割的最小单位。

数据元素可以包含数据元素（此数据元素内也包含数据项）和 数据项。树形结构，叶子结点



数据结构的划分：
按 逻辑结构 和物理结构（存储结构） 划分

●01.逻辑结构：是指数据对象中数据元素之间的前后减关系；可分为三类：
1）集合：（无逻辑关系）数据结构中的元素之间除了在"同属一个集合"的相互关系外，别无其他关系。

2）线性结构：就是表中各个结点具有线性关系，元素存在一对一的相互关系。主要包括以下几点：
1、线性结构是非空集。
2、线性结构有且仅有一个开始结点和一个终端结点。
3、线性结构所有结点都最多只有一个直接前驱结点和一个后继结点。
线性表就是典型的线性结构，还有一维数组、栈、队列和串等都属于线性结构。

3）非线性结构：表中各个结点之间具有多个对应的关系。主要包括以下几点：
1、非线性结构是非空集。
2、非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点。
多维数组、广义表、树结构和图结构等数据结构都属于非线性结构。、
树形结构：数据结构中的元素存在一对多的相互关系；
图形结构：数据结构中的元素存在多对多的相互关系。

扩展：
数组为什么不是线性结构？
一维数组是线性的，有队首队尾，有前驱和后继；
多维数组是非线性的，不只有水平方向的前驱和后继，还有竖直方向的。

●02.物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式。
1）顺序存储结构（顺序映象）：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。也就是其内存结构在物理方面是相连的。
2）链式存储结构（非顺序映象）：借助指示元素存储位置的指针来表示数据元素之间的逻辑关系。其内存结构在物理方面基本是不相连。
2）索引存储结构：其实也是非顺序的
2）散列存储结构：其实也是非顺序的

●03.常用的数据结构：
1）数组（Array）：一维数组是线性结构，二维多维数组不是线性结构
2）链表（LinkedList）：是一种数据元素按照链式存储结构进行存储的线性结构，所以物理上是非连续的。链表由一系列的数据结点狗偶成，每个数据结点包括数据域和指针域两部风。
其中指针域保存了数据结构中下一个元素存放的地址（单链表）；要是还有上一个就是双链表；尾部结点指点头部的就是循环链表。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。
3）队列（Queue）：也是一种特殊的线性表，队列只允许在表的一端进行插入，在另一端进行删除。一般来说，进行插入操作的一段称为队尾，进行删除操作的称为队头，队首。
4）栈（Stack）：一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。后进先出（先进后出，后来居上）。
5）堆（Heap）：堆是一种特殊的属性结构，一般讨论的对都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。
6）树（Tree）：树是典型的非线性结构，他包括，2个结点的有穷集合K。在树的结构中，有且仅有一个根节点，该结点没有前驱结点。在树的其他结点都有且仅有一个前驱结点，可以有两个后继结点。
7）图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。
8）散列表（Hash）：散列表源自于散列函数（Hash function）,其实就是哈希函数（这绕口的名称），Hash的实现是个单链表，所以也是一个线性表。在结构中查找时是从head开始往下进行key的比较，查找的，所以查找的效率依赖于查找过程中所进行的比较次数。效率低。

扩展：HashMap中get使用的hashcode是object类中的，因为有的类里重写了hashcode方法。


●01.数组
1）一维数组是线性结构，多维数组是非线性
2）占据连续内存：数组空间连续，按照申请的顺序存储，但是必须制定数组大小。
3）数组空间效率低：数组中机场有空闲的区域没有得到充分的应用。
4）操作麻烦：数组的中间增加和删除操作很麻烦。

线性表：线性结构，多个元素有序排列的有限序列，只是逻辑层次上的，而不考虑物理（存储）层次。所以链表依然是线性表。
在细分可以分为一般线性表和受限线性表。受限线性表主要包括栈和队列，受限表示对节点的操作受限制。

●01.顺序表: ArrayList，物理结构为顺序存储结构
1）add
2）remove：可以是位置，也可以是对象
3）set(index,E)：修改指定位置的值
4）get
优点：尾部插入效率高，支持随机访问
缺点：中间插入或者删除效率低，

什么情况下不要用ArrayList？
涉及到插入和删除的操作不要用。

在ArrayList中间增加删除为什么效率低？
因为增加和删除时会复制这个位置之后的item，前进或者后退一位。

●02.链表：物理结构为链式存储结构。
特点是：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
单链表：内含自身元素，与下一个结点。HashMap
双链表：内含自身元素，以及上下两个结点。LinkedList

顺序表：
优点：
存储空间连续，允许随机访问，尾插，尾删方便。
缺点：
中间插入和删除效率低，长度固定，造成空间浪费。

单链表：
优点：
随意进行增删改，插入删除效率高，长度可以随意修改。
缺点：
内存不连续，不能随机查找，只能从头部开始一个一个往下找，所以效率慢。

双链表：
优点：
随意进行增删改，插入删除效率高，长度可以随意修改，查找效率比单链表快。
缺点：
内存不连续，不能随机查找，只是双链表可以判断查找的位置离头尾的距离，然后开始找，所以比单链表快。

LRU算法
CPU缓存：位于CPU与内存之间的临时存储器。解决CPU速度和内存速度的速度差异问题。
●01.内存淘汰机制
1）FIFO (First In,First Out)先进的先被淘汰掉。
2）LFU (Least Frequently Used) 最不常用的淘汰掉
3）LRU (Least Recently Used) 最近最少使用的淘汰掉

●02.LRU算法的原理，或者说实现
此版本基于Android10.0或者Androidx.collection 1.1.0版本。各版本代码稍有不同，但基本思想就是这样的。
1）新建LRU对象，设置可使用的最大内存缓存maxSize。此时LRU的构造方法中会初始化一个 LinkedHashMap ，并把map的 AccessOrder 属性设为true，用来重排序。
2）put对象时，计算缓存size，map的put方法是在HashMap中实现的，分两种情况：
1、新添加的key，put 完成后会返回null，期间会调用 afterNodeInsertion （判断是否移除队首 head）不用管此方法。
2、key已存在，put 执行时会调用 afterNodeAccess(e) （判断头尾，并设置尾部）把当前替换的结点node移动到队尾，如果已在队尾，就跳出；然后会返回被替换的对象，再次计算size，并在 entryRemoved(false, key, previous, value) 方法中返回（可重写）；
最后和maxSize作比较，是否超限，超限移除head。
3）get对象时，value为空，返回null，可以重写 create(key) 方法，自定义一个对象，这之后就是put的流程了。不为空，直接返回该value，同时会在map中调用 afterNodeAccess(e) 把对象移动到队尾。
4）remove对象时，map移除对象，计算当前内存size，在entryRemoved中返回移除的对象，
5）resize(int maxSize) 设置缓存的大小。

●03.LinkedhashMap
1）队尾添加，队首移除，双链表结构，继承自HashMap；但HashMap是单链表；
2）LinkedHashMap继承了HashMap的Node,并增加了before和after两个字段；
3）内部通过 accessOrder 属性来控制 afterNodeAccess(e) 方法的执行，默认为false，也就是不执行；这个方法是每次都会把put（key存在，替换时）或get的node结点移到队尾。

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）
