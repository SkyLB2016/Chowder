数据结构与算法

第一章 数据结构的划分
第一节 数据结构的概念
●01.数据项，数据元素，数据对象，数据，数据结构 的概念
1）数据项：一个数据元素可以由若干数据项组成。也可以称为字段、域、属性
2）数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录、元素、结点、顶点。
3）数据对象：有相同性质的数据元素的集合，是数据的子集。
4）数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入个计算机处理的符号集合。数据不仅仅包括整形，实形等数值类型，还包括字符及声音、图像、视频等废树脂类型。
数据总体指的是计算机中的所有数据集合，而咱们一般说的数据指的是一条，一组数据。

5）数据结构：是互相之间存在一种或多种特定关系的数据元素的集合。
ArrayList 就是一个数据结构，里边的数组array就是数据对象

●知识扩展：
数据 == N个数据对象（N个不同类型的List列表里的array）
一个数据对象 == N个同类型的数据元素（list里array中的元素）
一个数据元素 == N个数据元素 + N个数据项，java类与对象
数据项是数据不可分割的最小单位。

数据元素可以包含数据元素（此数据元素内也包含数据项）和 数据项。树形结构，叶子结点

第二节 数据结构的划分：
按 逻辑结构 和物理结构（存储结构） 划分

●01.逻辑结构：是指数据对象中数据元素之间的前后减关系；可分为三类：
1）集合：（无逻辑关系）数据结构中的元素之间除了在"同属一个集合"的相互关系外，别无其他关系。

2）线性结构：就是表中各个结点具有线性关系，元素存在一对一的相互关系。主要包括以下几点：
1、线性结构是非空集。
2、线性结构有且仅有一个开始结点和一个终端结点。
3、线性结构所有结点都最多只有一个直接前驱结点和一个后继结点。
线性表就是典型的线性结构，还有栈、队列和串等都属于线性结构。

3）非线性结构：表中各个结点之间具有多个对应的关系。主要包括以下几点：
1、非线性结构是非空集。
2、非线性结构的一个结点可能有多个直接前驱结点和多个直接后继结点。
多维数组、广义表、树结构和图结构等数据结构都属于非线性结构。、
树形结构：数据结构中的元素存在一对多的相互关系；
图形结构：数据结构中的元素存在多对多的相互关系。

●知识扩展：数组为什么不是线性结构？
一维数组有可能是线性的，也可能是非线性的，
例如HashMap的实现是数组+链表，形象点说：竖直方向上是数组，横向上数组的每个结点又是一个链表；极端情况下，只在一个结点下存储元素，那他就是一个链表；或者每个结点下都只有一个元素，那他就是一个数组，此时是线性的。
多维数组都是是非线性的，不只有水平方向的前驱和后继，还有竖直方向的。

●02.物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式。
1）顺序存储结构（顺序映象）：借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系。也就是其内存结构在物理方面是相连的。
2）链式存储结构（非顺序映象）：借助指示元素存储位置的指针来表示数据元素之间的逻辑关系。其内存结构在物理方面基本是不相连。
2）索引存储结构：其实也是非顺序的
2）散列存储结构：其实也是非顺序的

●03.常用的数据结构：
1）数组（Array）：是一种聚合数据类型，它是将具有相同类型的若干变量有序的组织在一起的集合，可以说是最基本的数据结构
2）链表（LinkedList）：是一种数据元素按照链式存储结构进行存储的线性结构，所以物理上是非连续的。链表由一系列的数据结点狗偶成，每个数据结点包括数据域和指针域两部风。
其中指针域保存了数据结构中下一个元素存放的地址（单链表）；要是还有上一个就是双链表；尾部结点指点头部的就是循环链表。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。
3）队列（Queue）：也是一种特殊的线性表，队列只允许在表的一端进行插入，在另一端进行删除。一般来说，进行插入操作的一段称为队尾，进行删除操作的称为队头，队首。
4）栈（Stack）：一种特殊的线性表，它只能在一个表的一个固定端进行数据结点的插入和删除操作。后进先出（先进后出，后来居上）。
5）堆（Heap）：堆是一种特殊的属性结构，一般讨论的对都是二叉堆。堆的特点是根结点的值是所有结点中最小的或者最大的，并且根结点的两个子树也是一个堆结构。
6）树（Tree）：树是典型的非线性结构，他包括，2个结点的有穷集合K。在树的结构中，有且仅有一个根节点，该结点没有前驱结点。在树的其他结点都有且仅有一个前驱结点，可以有两个后继结点。
7）图（Graph）：图是另一种非线性数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。
8）散列表（Hash）：散列表源自于散列函数（Hash function）,其实就是哈希函数（这绕口的名称），Hash的实现是个单链表，所以也是一个线性表。在结构中查找时是从head开始往下进行key的比较，查找的，所以查找的效率依赖于查找过程中所进行的比较次数。效率低。

●04.数组
1）是一种聚合数据类型，最基本的数据结构。
2）占据连续内存：数组空间连续，按照申请的顺序存储，但是必须制定数组大小。
3）数组空间效率低：数组中有空闲的区域没有得到充分的应用。
4）操作麻烦：数组的中间增加和删除操作很麻烦。

第二章 线性结构
线性表：多个元素有序排列的有限序列，只是逻辑层次上的，而不考虑物理（存储）层次。所以链表依然是线性表。
在细分可以分为一般线性表和受限线性表。受限线性表主要包括栈和队列，受限表示对节点的操作受限制。

第一节 顺序表、单链表、双链表
●01.顺序表: ArrayList，内部使用数组实现，所以物理结构为顺序存储结构
优点：尾部插入效率高，支持随机访问
缺点：中间插入或者删除效率低
set(index,E)：修改指定位置的值，我都没用过

●知识扩展：什么情况下不要用ArrayList？在ArrayList中间增加删除为什么效率低？
因为ArrayList内部使用数组实现的，所以在中间插入的时候，这个位置之后的元素都要复制往后移动一个位置。
删除的时候是这个位置之后的元素都要往前移动一个位置。要是频繁移动，效率肯定低下。所以涉及中间插入和删除的操作不要用。还有排序。

●02.链表：物理结构为链式存储结构。
特点是：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。
单链表：内含自身元素，与下一个结点。HashMap
双链表：内含自身元素，以及上下两个结点。LinkedList

●知识扩展：顺序表、单链表、双链表的优缺点？
顺序表：
优点：存储空间连续，允许随机访问，尾插，尾删方便。
缺点：中间插入和删除效率低，长度固定，造成空间浪费。

单链表：
优点：随意进行增删改，插入删除效率高，长度可以随意修改。
缺点：内存不连续，不能随机查找，只能从头部开始一个一个往下找，其实就是顺序查找，所以效率慢。

双链表：
优点：随意进行增删改，插入删除效率高，长度可以随意修改，查找效率比单链表快。
缺点：内存不连续，不能随机查找，只是双链表可以判断查找的位置离头尾的距离，然后开始找，所以比单链表快。

第二节 LRU算法
CPU缓存：位于CPU与内存之间的临时存储器。解决CPU速度和内存速度的速度差异问题。

●01.内存淘汰机制
1）FIFO (First In,First Out) 先进先出。队列
2）LFU (Least Frequently Used) 最不常用的淘汰掉
3）LRU (Least Recently Used) 最近最少使用的淘汰掉

●02.LruCache 的实现原理？
此版本基于Android10.0或者Androidx.collection 1.1.0版本。各版本代码稍有不同，但基本思想就是这样的。
1）新建LRU对象，设置可使用的最大内存缓存maxSize；此时LRU的构造方法中会初始化一个 LinkedHashMap ，并把map的 AccessOrder 属性设为true，用来重排序。
2）put对象时，计算缓存size，map的put方法是在HashMap中实现的，分两种情况：
1、新添加的key或hash定位冲突，put 完成后会返回null，期间会调用 afterNodeInsertion （判断是否移除队首 head）不用管此方法。
2、key已存在，put 执行时会调用 afterNodeAccess(e) （判断头尾，并设置尾部）把当前替换的结点node移动到队尾，如果已在队尾，就跳出；然后会返回被替换的对象，再次计算size，并在 entryRemoved(false, key, previous, value) 方法中返回（可重写）；
最后和maxSize作比较，是否超限，超限移除head。
3）get对象时，value为空，返回null，可以重写 create(key) 方法，自定义一个对象，这之后就是put的流程了。不为空，直接返回该value，同时会在map中调用 afterNodeAccess(e) 把对象移动到队尾。
4）remove对象时，map移除对象，计算当前内存size，在entryRemoved中返回移除的对象，
5）resize(int maxSize) 设置缓存的大小。

●03.LinkedhashMap
1）双链表结构，继承自HashMap；但HashMap是单链表；
2）LinkedHashMapEntry 继承了 HashMap 的 Node，并增加了before和after两个字段；
3）内部通过 accessOrder 属性来控制 afterNodeAccess(e) 方法的执行，默认为false；afterNodeAccess方法每次都会把 put（key存在，替换时）或 get 的 node结点移到队尾。


第三节 队列（Queue）
说明：一种特殊的线性表，队列只允许在表的一端进行插入（入队），称为队尾；在另一端进行删除（出队），称为队头，队首。队列中没有元素时，称为空队列。
只有最早入队的元素才能最先出队，故队列又称为先进先出线性表。FIFO--first in first out
●01.循环队列：
说明：为充分利用向量空间，克服假溢出，将向量空间想先给一个守卫相接的圆环，并称这种向量为循环向量。
存储在其中的队列称为循环队列（Circular Queue）。循环队列是把顺序队列首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。

ArrayBlockingQueue 是这么玩的，之所以这样是因为数组内存是连续的，必须要重复利用，不然就会假溢出。其中有两个属性 putIndex（下一次放入的位置），takeIndex（下一次移除的位置），等于array的长度时，就至为0；要是两者相等，那队列为空。还有一个 count 属性会在每次入队时，自加，出队时，自减。
LinkedBlockingQueue 不是这么干的，因为内存不连续，所以不存在假溢出这个问题。其中数量count的自增自减使用的 AtomicInteger 乐观锁。

注意 LinkedBlockingQueue 是单链表的线性表，LinkedList 是双链表的线性表。尼玛。

●02.双端队列：一种具有队列和栈的性质的数据结构。双端队列中的元素可以从两端弹出，其限定插入和删除操作在表的两端进行。
受限的双端队列：
1）一端只允许插入和删除，另一端只允许插入
2）一端只允许插入和删除，另一端只允许删除
3）从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个底栈相邻的栈了。

常用的双端队列：
LinkedList，它实现了Queue这个接口
ArrayDeque
LinkedBlockingDeque：加了锁机制的双端队列

●03.优先级队列：
1）MeaageQueue：就是一个优先级队列，根据消息的延迟时间来排序handler。
2）PriorityQueue：
PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
3）DelayQueue：一个使用优先级队列实现的无界阻塞队列。

●04.阻塞队列
1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。
2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。

阻塞队列产用于生产者和消费者的场景。生产者插入，消费者取出。
常用方法    抛出异常    返回特殊值   一直阻塞
插入方法    add()       offer(e)    put(e)
移除方法    remove()    poll()      take()
检查方法    element()   peek()      不可用

抛出异常：
当队列满时，再插入，会抛出IllegalStateException("QueueFull")异常。
当队列空时，获取会抛出noSuchElementException异常。

返回特殊值：
插入时会返回元素是否插入成功。
取出时，没有会返回null。

一直阻塞：
当队列满时，生产者线程put元素时，队列会一直阻塞生产者线程，直到队列可用或响应中断退出。
当队列空时，消费者线程take元素，队列会阻塞消费者线程，直到队列不为空。

常用阻塞队列：
ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。主要
LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。主要
LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。双端队列

LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
DelayQueue：一个使用优先级队列实现的无界阻塞队列。
PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
SynchronousQueue：一个内部只包含一个元素的阻塞队列。

第四节 栈（Stack）
说明：一种特殊的线性表，它只能在表的一个固定端进行数据结点的插入和删除操作。后进先出（先进后出，后来居上）。
术语：压栈，进栈；出栈，退栈。空栈。
有顺序结构，也有链式结构。

●01.Java中的 Stack 是通过 Vector 来实现的，这种设计被认为是不良的设计，说说你的看法？
因为在 Vector 中可以定点插入删除数据，而继承了 Vector 的 Stack 自然也可以定点插入删除，这不符合栈的特性，所以它被认为是不良的设计。

●02.逆波兰表达式又叫做后缀表达式，就是把运算量写在前面，把运算符写在后面。

●03.StackOverFlowError与OutOfMemoryError，分别代表什么，有什么区别，职责是什么？
1）一个是栈溢出，一个是堆溢出。
2）栈解决了程序的运行问题，即程序如何执行，如何处理数据的问题。
堆解决的事数据存储的问题，即数据是怎样放，放在哪里。
3）栈负责的是运算逻辑。
堆负责的是存储逻辑。

●04.JVM的栈内存
Stack 与 Heap 都运行在内存上，在内存空间上字节码指令不必担心不同机器上的区别，所以JVM实现了与平台无关的特性。
JVM栈的每个栈帧（slot）大小都是4bytes，而一个slot恰好可以保持一个对象的引用，所以引用永远是4bytes。

第四节 HashMap的原理，10.0系统版本
内部是通过数组+单链表的形式封装的。竖直方向上是一个数组，横向上数组的每个结点又是一个单链表；极端情况下，只在一个结点下存储元素，那他就是一个链表；或者每个结点下都只有一个元素，那他就是一个数组，此时是线性的。
JDK8之后，Hash冲突后不再是用链表来保存相同index的结点，而是改成红黑树（高性能的平衡树）来保存冲突结点。
红黑树，，，，

●01.重要参数参数：
table：内部的node数组。
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16 ：数组最初的容量，所以最初的 threshold 是12.
loadFactor：加载引子，默认是0.75，用来计算threshold
threshold：阈值，当前map达到这个容量后，就需要重新增大调整空间的大小

●02.HashMap初始化时的配置
1）HashMap有四个构造函数：
无参数：只是把加载因子 loadFactor 设为默认的 DEFAULT_LOAD_FACTOR
2）有参数的有两个，都会转到两个参数的，初始容量，以及加载因子。初始容量会自动对齐2的n次幂。然后它赋值给了 threshold ？？
这三个构造函数，并没有初始化table，table会在put时，检测为空时调用 resize 方法初始化table，重置 threshold。

3）此构造函数是复制另一个HashMap。

●03.hash的put方法原理
简单来说先计算key的hash值，然后根据hash值计算对应的下标，再往链表中添加元素。
详细情况如下：
1）首先判断table是否为空，为空，开始初始化。因为构造函数还有扩容的问题，所以有三种情况：
第一种：table 为空，threshold 不为空，默认的容量Capacity=16，threshold=12，
第二种：table 为空，threshold 不为空，那就把 threshold 作为初始容量newCapacity=threshold，重新计算threshold。
第三种：table 不为空，也就是要扩容，oldCap 与 threshold 同时 左移一位就好，也就是扩大2倍。
2）接着会获取 key 的 hashcode，然后根据 hashcode 计算下标。(length - 1) & hash 等价于 hash % length 只有在 length 是 2的n次幂 时，这个等式才成立。
检查此下标下是否已存在节点，不存在直接创建新的结点，并加入数组中，计算数据容量，是否需要扩容，返回null。
3） 已存在，轮询此结点所在的链表，对比hash值和key，一直不相等，最后就是新添加一个结点，跳出循环，之后就是计算容量，检查容量，返回null。
相同，选出此结点，替换原有的value，并检测是否需要重新排序，返回被移除的value。

●04.hash的get方法原理
先计算key的hash值，然后计算数组对应的下标，获取链表，开始轮询找到对应的结点，并返回。
首先检测table是否为空，为空就返回null。
不为空，获取key的hash值，计算下标，从数组中取出单链表，开始比对hash值和key，返回相等的结点的value，没有则返回null。

●05.hash的remove方法
先计算key的hash值，然后计算数组对应的下标，获取链表，开始轮询找到对应的结点，并移除。
首先检测table是否为空，为空就返回null。
不为空，获取key的hash值，计算下标，从数组中取出单链表，开始比对hash值和key，返回相等的结点的value，没有则返回null。

●06.为什么要使用HashMap？
ArrayList查找快，增删慢。
LinkedList增删快，查找慢。
HashMap结合两者，所以查找快，增删也快。不过要论单个，当然还是他们自己快。

●07.什么是hash碰撞？
根据hash值计算的下标，肯定有重复的时候，这就是hash碰撞。

●08.为什么需要加载因子？
容器内数据越少，hash值碰撞的就越少，当达到一定阈值是，hash值会频繁碰撞，此时为解决此问题就需要扩容；loadFactor就是指定容器达到多大的比重时，开始扩容。

第五节 ThreadLocal
内部实现也是一个HashMap的变种，只不过这个map里放的是一个一位数据，没有链表。
其中key是Threadlocal本身。

●01.set方法的实现
1）首先获取当前线程，获取线程内的map threadLocals，为空就创建map。
2）不为空，设置value。其中会先获取ThreadLocal的hashCode，这是一个通过 AtomicInteger 实现的唯一值。
3）然后通过hashcode计算下标，（这里才是重点）通过下标获取node，为空跳出循环，插入数据，然后size自加，尝试清空过时条目与比较阈值，是否需要扩容。
不为空，key相等则设置，返回；不相等，下次一循环（这里是让下标加1，查找下一个，而不是通过链表的next），为空则跳出循环，执行插入操作。

●02.get方法的实现
1）首先获取当前线程，获取线程内的map threadLocals，为空就通过初始值创建map，并返回初始值。
2）不为空，就通过map获取对应的node，取出对应的value，返回。

第六节 容器总结
●01.ArrayList既然继承自AbstractList抽象类，而AbstractList已经实现了List接口，那么ArrayList为何还要再继承List接口呢？
为了方便实现动态代理类，动态代理是会获取接口信息，没有直接继承，就获取不到。


第三章 树结构

第一节 概念相关

●01.什么是树结构？
N个结点构成的有限集合；
树中有一个称为"根（Root）"的特殊结点；
奇鱼结点可分为若干个互不相交的树，称为原来结点的子树。

1）结点的度：一个结点含有的子结点的个数称为该 结点的度。
2）叶结点或 终端结点：度为0的结点。最边上的。
3）非终端结点或分支结点：度不为0的结点。
4）父结点或双亲结点：若一个结点含有子结点，则这个结点称为其子结点的父结点。
5）子结点：一个结点含有的子树的根节点称为该结点的子结点，也就是说不是整棵树都是他的子结点。
6）兄弟结点：具有相同父结点的结点互称为兄弟结点。
7）树的度：一棵树中，最大的结点的度称为树的度。
8）结点的层次：从根开始定义起，根为第一层，根的子结点为第2层，以此类推。
9）树的高度或深度：树中结点的最大层次。
10）堂兄弟结点：双亲在同一层的结点互为堂兄弟。
11）结点的祖先：从根到该结点所经分支上的所有结点。
12）子孙：以某结点为根的子树中任意结点都称为该结点的子孙。
13）森林：由M棵互不相交的树的集合称为森林。

●02.树的种类
1）无序树 或 自由树：树中任意节点的子结点之间没有顺序关系。
2）有序树：树中任意节点的子结点之间有顺序关系。
3）二叉树：每个节点最多含有两个子树的树。完全二叉树，满二叉树。
4）完全二叉树：只有最下面两层的结点的度数可以小于2，并且最下层的结点都集中在该层最左边的若干位置上。左边层数要么等于右边层数，要么大一层。
5）满二叉树：层数为K，结点总数是 2^k-1，就是满二叉树。
5）哈弗曼树：带权路径最短的二叉树称为哈弗曼树或最优二叉树。

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）

●0.
1）
2）
3）
4）
5）
5）
