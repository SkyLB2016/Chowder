Java教程笔记

●01.Java特性
1）简单的，类似C；
2）面向对象的；
3）分布式的；
4）健壮的；
5）安全的；
6）体系结构中立的；
7）可移植的；
8）解释型的；
9）高性能的；
10）多线程的；
11）动态的：云端更新类。

●02.一些概念一系列对象的集合，通过调用彼此的方法来协同工作。彼此间的概念：对象，类，方法，变量.
1）对象：对象是类的一个实例，有具体的状态和行为（方法）；比如一个人：种族，名字等是状态（属性），去干什么是行为。
2）类：类是个模板，描述一类对象的行为和状态。
3）方法：方法就是行为，也就是做什么。所有的操作均在方法中执行
4）实例变量：也就是状态，属性，每个对象都有自己独特的实例变量。对象随着属性而变化。

●03.需要注意的
1）大小写敏感；
2）类名首字母大写，也就是大驼峰模式；
3）方法名为小驼峰模式；
4）原文件名与类名相同
5）主方法入口为：main

●04.Java标识符：
1）所有的标识符都应该以字母、美元符号$、下划线_ 开头，之后随意。
2）关键字不能作为标识符；
3）大小写敏感

●05.Java关键字，见另一篇笔记

●06.Java变量：
1）局部变量：
位于方法中，方法执行时创建，执行完毕后销毁；
不能用修饰符修饰
只在方法体中可见
内存位置是分布在栈上的
没有默认值，被声明后必须初始化，才可以使用。
2）成员变量（非静态）：
位于类中方法块之外；
对象创建后，其中的实例变量的值就跟着确定了；
可使用修饰符修饰；
八大基本类型有各自的默认值，其他类则为null。
3）静态变量（类变量）：
位于类中，方法块之外，static修饰的变量；
在内存中只有一份拷贝，存储在静态存储区，经常被使用为常量，偶尔用作变量；
类名直接使用。

●07.继承
1）在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。
2）利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。

●08.接口
1）在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。
3）接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。

●09.构造方法：每个类都有默认构造方法（隐式的方法），不带参数；要是自己重写了，那默认的就没有了，需要的话，可以自己定义。

●10.创建对象的过程：
1）声明：声明一个对象，也就是变量，包含对象名称和对象类型。
2）实例化：使用new关键字来创建一个对象。
3）初始化：使用new关键字来创建对象时，会调用构造方法来初始化对象。

●11.Java基本数据类型：变量就是申请内存来存储值，即创建变量就需要分配内存。内存管理系统根据变量的类型来为变量分配存储空间。
1）内置数据类型：八种基本类型，都有对应的包装类。
2）引用数据类型：由类的构造函数创建，变量类型一旦声明后不可改变，默认值为null。
3）Java常量：指不能改变的量，final符修饰的变量。

●12.String<StringBuffer<StringBuilder
1）String是字符串常量，不可变，每次修改都相当于生成一个新的对象，所以不适合经常变更值的场景
2）StringBuffer是线程安全的，使用了synchronized修饰，适用于多线程
3）StringBuilder不是线程安全的，适用于单线程，所以效率略快于StringBuffer。
4）速度上面String不断地复制和变更是创建不同的对象进行操作，如String a="a"+"b"+"c"，其内部会自动转成StringBuilder的拼接，数据多的时候会创建循环来拼接，builder的创建有可能会放在循环里边，会影响GC的回收，要避免。
5）StringBuffer和StringBuilder只是处理同一个对象，不影响GC的回收。
6）字符串重新赋值，是回收旧值，把值赋给一个新的str，也就是内存地址已换，是一个新的对象；
用System.identityHashCode(entity))来获取内存地址。

●13.IO流
一、Java流的分类
1）按流向分:
输入流: 程序可以从中读取数据的流。
输出流: 程序能向其中写入数据的流。
2）按数据传输单位分:
字节流: 以字节为单位传输数据的流，通常用来读取二进制数据，如图象和声音。
字符流: 以Unicode字符为单位传输数据的流，通常用来读写文本信息。
3）按功能分:
节点流: 用于直接操作目标设备的流
过滤流: 是对一个已存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能。
二、java.io常用类，位于JDK的java.io包中，都分别继承自以下四种抽象流类：
1）InputStream：输入流，用于向程序中输入数据的，字节流，单位：字节byte（8位）。
2）OutputSteam：输出流，程序用于向外输出数据的，字节流，单位：字节byte（8位）。
3）Reader：输入流，用于向程序中输入数据的，单位：字符char（16位）。
4）Writer：输出流，程序用于向外输出数据的，单位：字符char（16位）。
5）InputStreamReader将InputStream转化成Reader
6）OutputStreamWriter将OutputStream转化成Writer

●14.引用方式有几种？四种，分别是
1）强引用：直接用等号（=）赋值的引用方式。

2）软引用：使用 SoftReference 包装的引用，内存不足时，就会被回收；通常会结合ReferenceQueue（引用队列）来使用，再被内存回收后，会被加载到队列中。
通常可用来实现内存敏感的高速缓存，如内存中的图片缓存。

3）弱引用：使用 WeakReference 包装的引用，GC发现了就会回收。也会结合ReferenceQueue来使用。
通常用于debug，内存见识工具等程序中。因为这类程序一般要求纪要观察到对象，又不能影响该对象正常的GC过程。

4）虚引用：使用 PhantomReference 包装，必须与ReferenceQueue联合使用。随时回收，而且他是回收前，就已经被放到关联队列中了。

5）String abc = soft.get(); 相当于强引用

●15.Java内存优化
1）释放连接
2）优化逻辑，释放不必要的对象，尽量使用局部变量。
3）减少循环逻辑里的对象创建
4）基本类型代替对象类型使用StringBuffer（线程安全的）和StringBuilder（非线程安全，所以论速度，比buffer快）替代多次String对象
5）单线程尽量使用HashMap和ArrayList
6）提前分配StringBuffer，数组，array，vertor等的容量
7）合适的场所使用单例
8）尽量不要随意使用静态变量
9）处理内存泄漏

●16.接口和抽象类的区别
1）接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
2）类可以实现和多个接口，但是只能继承一个抽象类。
3）类如果要实现一个接口，他必须要实现接口生命的所有方法。但是类可以不识闲抽象类生命的所有方法，当然在这种情况下，类也必须声明成抽象的
4）抽象类可以在不提供接口方法实现的情况下实现接口。
5）Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
6）Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected，public，default。
7）接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是如果它包含main方法的话是可以被调用的。

●17.获取当前方法的名称的两种方法。推荐第一种
1）StackTraceElement[] traceElement = Thread.currentThread().getStackTrace();
此方法取得的StackTraceElement栈：
第零条数据是VmStack的getThreadStackTrace；
第一条数据是Thread的getStackTrace
第二条数据是当前方法的所在位置。
2）StackTraceElement stack = new Throwable().getStackTrace();
此方法取得的StackTraceElement栈，它的第零条数据就是当前方法所在的位置。
StackTraceElement的属性
String declaringClass; 类的全名；getMethodName
String methodName; 对应的方法名；getClassName
String fileName; 类名；getFileName
int    lineNumber; 对应代码的行数；getLineNumber

●17.
1）
2）
3）
4）
5）
6）
7）
8）
9）