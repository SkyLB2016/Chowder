享学课堂

加油学习
专用名词：
缺省：就是默认
实参：实际参数，类中定义的，可以是常量，变量，表达式，函数等，还有类型（泛型结构中的T）。
形参：形式参数，就是方法后边的参数名，用来在方法被调用时，接收传进来的实参具体的值。
原生类型：就是基本数据类型。

Java中的泛型
●01.泛型的好处，或者说为什么需要泛型？
1）适用于多种数据类型执行相同的代码。
2）泛型中的类型在使用时指定，不需要强制类型转换。

●02.泛型类、泛型接口、泛型方法，可以理解成“参数化类型”，将类型作为实参传入，形参接收；
都必须带<>，通常使用 T、E、K、V，可以多个参数，当然也可以是全拼，如AsyncTask就是这么用的。
其中泛型方法在泛型类和普通类中都可以使用。
泛型的本质是为了参数化类型（在不创建新类的情况下，通过泛型指定的不同类型来控制形参的具体限制的类型）。
也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法、

●03.实现泛型接口的类，有两种方法：除了泛型参数，其他的和普通类没区别。
1）可继承时不传入泛型实参，也就是继续保持T，但new时必须指定具体类型。如list创建，不指定那就是Object
2）继承是直接传入泛型实参。

●04.限定类型变量
1）T extends XXX：T代表应该绑定的子类型，XXX表示这个类型的超类上限；
extends左右都允许有多个，限定类型书写规则为：类&接口&接口，有类，则类必须在最前，且只能有一个类，接口可以多个。
T,V extends Serializable&Comparable
逗号分隔是不继承的，只是VDE继承。

●05.泛型中的约束和局限性
1）不能用八种基本类型实例化参数，必须是换成八种类型的包装类才行，因为基本类型不是对象。
2）泛型类实例化时，前后的类型必须统一，即使是继承关系的也不行。
3）不能用 list instanceof List<String>做比，因为java中的泛型是伪泛型，包装的时候后边的类型会被擦除，然后转成object或者继承的超类。
4）不能实例化类型变量，也就是不能new T()
5）list通过getclass()方法获取的类名，是不带后边类型参数的。
6）不能在静态域或方法中使用，泛型是对象创建时才初始化，而静态域与方法是在new之前就创建好的。但是本身就是泛型方法就可以，如：
private static <T> T getInstance(){};
因为调用的同时类型就确定了，所以可以使用。
7）不能创建参数化类型的数组，但是不带就行了，不过不推荐，还是用list比价好。
ApiResponse<String>[] response = new ApiResponse<String>[2]; //不可以
ApiResponse<String>[] response = new ApiResponse[2];//可以
8）泛型类不能继承Exception/Throwable，这么写是不行的：A<T> extends Exception;
泛型可以继承Exception，例：T extends Exception，但是不能捕获也就是不能catch到继承Exception/Throwable的泛型类实例，但是可以抛出，也就是throws T

●06.通配符类型，只在方法参数以及成员变量中使用，不能在类中使用，可以从是否能安全转型来理解。
1）无限通配符：?，表示对类型没有限制，当成object理解就行了，调用getFist返回的是object类型，setFist不能被调用。
2）? extends XX:规定了表示传递个方法的参数，必须是XX的子类，主要用于安全的访问数据，可以访问X及其子类型，并且不能写入非空数据
public void print(GenericType<? extends XX> type){}//传入的参数只能是XX以及他的子类
GenericType<? extends XX> type;

GenericType<? extends XX> type=new GenericType<>();
type.setData(new Child());//不能这样设置，传入的子类具体是哪个是不确定的。
type.getData();//可以获取

3）？super XX:必须是xx的超类，主要用于安全的写入数据，可以写入X及其子类。
public void print(GenericType<? supper XX> type)//传入的参数只能是XX以及他的超类
GenericType<? supper XX> type;

GenericType<? super XX> type=new GenericType<>();
type.setData(new XXX());//不能设置为XX的父类，和作为参数时，不一样啊，这个，，，没办法，只能记住了。
type.setData(new AB());//只能是他本身或其子类，
Object data=type.getData();//可以获取，但获取的是object对象

或者可以这么理解，set的时候因为XX及其子类可能存在父类没有的方法，所以父类不能安全转型成XX，也有可能这个类本身就是继承父类的其他类，所以不让设置没所以取得时候，取出来的是Object对象。

●08.虚拟机是如何实现泛型的？
在C#中，List<Integer> 与List<String>是两个不同的类型，在系统运行初期生成，有自己的方法和数据，这种实现成为类型膨胀，基于这种方法实现的泛型成为真泛型。
java语言中的泛型不一样，他只在程序源码中存在，在编译后的字节码中，就已经替换为原来的原生类型object（Raw Type，也称为裸类型），并且在合适的地方插入了强转代码，因此List<Integer> 与List<String>就是同一个类，
所以泛型技术实际上是java语言的一颗语法糖，JAVA语言中的泛型实现方法为类型擦除，基于这种方法实现的泛型成为伪泛型。
所以将一段java代码编译成class文件后，再用字节码反编译工具进行反编译后，泛型就都不见了，程序又变回了java泛型出现前的写法，泛型都变回了原生类型。
限定列表是接口和类的，默认取第一个类（接口）作为原生类型。

●09.是不是同一个方法，jdk是靠返回类型，方法名，参数三者来判断的，但编译工具只判断方法名和参数。

●10.由于类型的擦除导致泛型类是一样的，所以JCP组织对虚拟机规范做出了相应的修改，引入了注入Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题。
Signature是其中最重要的一项属性，他的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确的识别Signature参数。
另外，从Signature属性我们还可以得出结论，擦除仅仅只是对code属性中的字节码进行擦除，但是元数据还是保存了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。


反射原理以及动态代理模式
●01.反射 Reflection
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
反射是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection Api取得任何类的内部信息，并能直接操作人以对象的内部属性及方法。
发射机制主要提供了一下功能：
1）在运行时构造任意一个类的对象
2）在运行时获取任意一个类所具有的成员变量和方法
3）在运行时调用任意一个对象的方法或属性。

●02.Class类，也是一个类，他的作用是用来描述类的，也就是对类的封装，一个类可以有多个实例对象，但是只会有一个class实例对象，这个class对象里包含了这个对象所对应的类的类名，属性，方法，构造器，接口信息等。
获取class实例的三种方式
1）通过类名获取：类名.class
2）通过对象获取：对象引用名.getclass()
3）通过全类名获取：Class.ForName(全类名)

●03.class常用方法：
1）static Class forName(String name) 返回指定类名name的class对象
2）Object newInstance() 嗲用缺省构造函数，返回该class对象的一个实例
3）Object newInstance(Object[] args) 调用当前格式构造函数，返回该class对象的一个实例
4）getName() 返回此Class对象所表示的实体（类、接口、数据类、基本类型或Void）名称
5）Class getSuperClass() 返回当前Class对象的父类的Class对象
6）Class[] getInterFaces() 返回当前Class对象所有的接口
7）ClassLoader getClassLoader() 返回该类的类加载器

获取构造器：需要转成指定对应实例的泛型
getConstructors() 全部构造器
getConstructor(Class<?> params) 单个构造器，以及对应的参数

获取方法
getMethods()  获取所有的public方法，包含父类的
getDeclaredMethods() 获取自身所有-的方法，包含私有的。
getDeclaredMethod() 获取指定方法

获取属性
getFields() 获取所有的public属性，包含父类的
getDeclaredFields() 获取自身的所有属性
getDeclaredField() 获取指定属性

setAccessible() 访问私有的

●04.Proxy InvocationHandler
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）
