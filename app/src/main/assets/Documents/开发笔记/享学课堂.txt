享学课堂

加油学习。面试其实就是考试，你想拿优秀，还是不及格呢？

专用名词：
缺省：就是默认
实参：实际参数，类中定义的，可以是常量，变量，表达式，函数等，还有类型（泛型结构中的T）。
形参：形式参数，就是方法后边的参数名，用来在方法被调用时，接收传进来的实参具体的值。
原生类型：就是基本数据类型。

Java中的泛型
●01.泛型的好处，或者说为什么需要泛型？
1）适用于多种数据类型执行相同的代码。
2）泛型中的类型在使用时指定，不需要强制类型转换。

●02.什么是泛型，有哪些？
泛型是操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法，三者互不影响，可以同时存在。

扩展：
可以理解成“参数化类型”，将类型作为实参传入，形参接收；
泛型类和泛型接口的<>在类和接口的名称后边，泛型方法的<>在返回值前边，通常使用 T、E、K、V，可以多个参数，当然也可以是全拼，如AsyncTask就是这么用的。
泛型的本质是为了参数化类型（在不创建新类的情况下，通过泛型指定来控制形参的具体类型）。
泛型除了泛型参数外，其他的和普通类没区别。

●03.限定类型变量
1）T extends X：T代表应该绑定的子类型，X表示这个类型的超类上限；
限定类型书写规则为：T,V extends 类&接口&接口；有类则类必须在最前，且只能有一个，接口可以多个。逗号分隔是不继承的。
T,V extends Serializable&Comparable
T与后边的类和接口没有继承关系

●04.泛型中的约束和局限性：八种
1）不能实例化类型变量，也就是不能new T()
2）不能用八种基本类型作为实例化参数；必须是换成八种类型的包装类才行，因为基本类型不是对象。
3）泛型类实例化时，前后的泛型类型必须统一，即使是继承关系也不行。
4）因为对象通过getclass()方法获取的类名是不带后边类型参数的，所以不能用 instanceof 做比。java中的泛型是伪泛型，包装的时候后边的类型会被擦除，强制转成Object或者继承的超类（第一个）。
5）不能在静态域或方法中使用，因为泛型是对象创建时才初始化，而静态域与方法是在new之前就创建好的。
但是本身就是泛型方法就可以，如：
private static <T> T getInstance(){};
因为调用的同时类型就确定了，所以可以使用。

6）不能创建参数化类型的数组，但是不带就行了，不过不推荐，还是用 List 更好。
ApiResponse<String>[] response = new ApiResponse<String>[2]; //不可以
ApiResponse<String>[] response = new ApiResponse[2];//可以
7）泛型类不能继承Exception/Throwable，这么写是不行的：A<T> extends Exception;
可以作为限定类型Exception，例：T extends Exception，但是不能捕获也就是不能catch到继承Exception/Throwable的泛型类实例，但是可以抛出，也就是throws T

●05.通配符类型，只在方法参数以及成员变量中使用，不能在类中使用，可以从是否能安全转型来理解。
1）无限通配符：?，表示对类型没有限制，当成object理解就行了，调用getFist返回的是object类型，setFist不能被调用。
2）? extends X:规定了表示传递个方法的参数，必须是X的子类，主要用于安全的访问数据，可以访问X及其子类型，并且不能写入非空数据
public void print(GenericType<? extends X> type){}//传入的参数只能是X以及他的子类

GenericType<? extends X> type=new GenericType<>();
type.setData(new Child());//不能这样设置，传入的子类具体是哪个是不确定的。
X x=type.getData();//可以获取，返回X

3）？super X:必须是X的超类，主要用于安全的写入数据，可以写入X及其子类。
public void print(GenericType<? supper X> type)//传入的参数只能是X以及他的超类

GenericType<? super X> type=new GenericType<>();
type.setData(new X());//不能设置为X的父类，和作为参数时，不一样啊，这个，，，没办法，只能记住了。
type.setData(new child());//只能是他本身或其子类，
Object data=type.getData();//可以获取，但获取的是object对象

或者可以这么理解，set的时候因为X及其子类可能存在父类没有的方法，所以父类不能安全转型成X，也有可能这个类本身就是继承父类的其他类，所以不让设置父类，所以取得时候，取出来的是Object对象。

●06.虚拟机是如何实现泛型的？
在C#中，List<Integer> 与List<String>是两个不同的类型，在系统运行初期生成，有自己的方法和数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真泛型。
java语言中的泛型不一样，他只在程序源码中存在，在编译后的字节码中，就已经替换为原来的原生类型object（Raw Type，也称为裸类型），并且在合适的地方插入了强转代码，因此List<Integer> 与List<String>就是同一个类，
所以泛型技术实际上是java语言的一颗语法糖，JAVA语言中的泛型实现方法为类型擦除，基于这种方法实现的泛型称为伪泛型。
所以将一段java代码编译成class文件后，再用字节码反编译工具进行反编译后，泛型就都不见了，程序又变回了java泛型出现前的写法，泛型都变回了原生类型。
如果是限定列表，那就默认取第一个类（接口）作为原生类型。
由于类型的擦除导致泛型类是一样的，所以JCP组织对虚拟机规范做出了相应的修改，引入了注入Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题。
Signature是其中最重要的一项属性，他的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确的识别Signature参数。
另外，从Signature属性我们还可以得出结论，擦除仅仅只是对code属性中的字节码进行擦除，但是元数据还是保存了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。

是不是同一个方法，jdk是靠返回类型，方法名，参数三者来判断的，但编译工具只判断方法名和参数。

反射原理以及动态代理模式
●01.反射 Reflection
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
反射是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection Api取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。
发射机制主要提供了一下功能：
1）在运行时构造任意一个类的对象
2）在运行时获取任意一个类所具有的成员变量和方法
3）在运行时调用任意一个对象的方法或属性。

●02.Class类，也是一个类，他的作用是用来描述类的，也就是对类的封装，一个类可以有多个实例对象，但是只会有一个class实例对象，这个class对象里包含了这个对象所对应的类的类名，属性，方法，构造器，接口信息等。
获取class实例的三种方式
1）通过类名获取：类名.class
2）通过对象获取：对象引用名.getclass()
3）通过全类名获取：Class.ForName(全类名)

●03.class常用方法：
1）static Class forName(String name) 返回指定类名name的class对象
2）Object newInstance() 嗲用缺省构造函数，返回该class对象的一个实例
3）Object newInstance(Object[] args) 调用当前格式构造函数，返回该class对象的一个实例
4）getName() 返回此Class对象所表示的实体（类、接口、数据类、基本类型或Void）名称
5）Class getSuperClass() 返回当前Class对象的父类的Class对象
6）Class[] getInterFaces() 返回当前Class对象所有的接口
7）ClassLoader getClassLoader() 返回该类的类加载器

获取构造器：需要转成指定对应实例
getConstructors() 全部构造器
getConstructor(Class<?> params) 单个构造器，以及对应的参数

获取方法
getMethods()  获取所有的public方法，包含父类的
getDeclaredMethods() 获取自身所有-的方法，包含私有的。
getDeclaredMethod() 获取指定方法

获取属性
getFields() 获取所有的public属性，包含父类的
getDeclaredFields() 获取自身的所有属性
getDeclaredField() 获取指定属性

setAccessible() 访问私有的

●04.代理模式，分为静态代理，与动态代理（Proxy InvocationHandler）

静态代理包含：接口，实现类，包含实现类的代理类（同样继承接口，在相同的方法内调用实现类的方法），访问者。
缺点是扩展能力差，可维护性差

动态代理与静态代理唯一的差别就是在使用时动态代理类生成代理类。
优点是：由于其中代理类是使用代码自动生成，减少了重复类的创建。

缺点是：由于使用反射，所以效率比较低。
应用场景局限，因为java的单继承特性（每个代理类都继承了Proxy类），即只能针对接口创建代理类，不能针对类创建代理类。

Proxy是用来创建动态代理类的类。
InvocationHandler是给动态代理类实现的，负责处理调用接口里的方法。

类的完整生命周期：java源文件->java字节码->class对象->实例对象->卸载；周而复始。


多线程与线程池

多核心：单芯片多处理器（Chip Multiprocessors，简称CMP），是有美国斯坦福大学提出的，其思想是将大规模并行处理器中的SMP（对称多处理器）集成到同一芯片内，各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向，称为并行处理。
多线程：Simultaneous Multithreading。简称SMT，SMT可通过复制处理器上的结构状态，让同一个处理器上的多个线程同步执行并共享处理器的执行资源，可最大限度地实现宽发射、乱序的超标量处理，提高处理器运算部件的利用率，缓和由于数据相关或Cache未命中带来的访问内存延时。

●01.CPU的核心数与线程的关系：
一般一个核心对应一个线程，但是拥有超线程的核心可以一对二。

●02.CPU的时间片轮转机制，是一种最古老、最简单、最公平且使用最广的算法，也称为RR调度。
每个线程被分配一个时间段，称作他的时间片，即该线程允许运行的时间。
也就是把CPU的运行时间切片，如一秒切成10份，100份。不同的系统，时间片大小不一样。

时间到还在运行，CPU将被剥夺，所以sleep、yield等阻塞代码在执行时，虽然锁没有释放，但是CPU已经去执行别的线程了。
RR调度中损耗时间最大的可能就是线程切换（上下文切换），从一个线程切换到另一个，需要保存和装入寄存器值及内存映像，更新各种表格和队列等，一次大概消耗20000个CPU时间周期。1+1就相当于一个时间周期。
线程过多就会频繁切换线程，造成大量的上下文切换，会大量浪费CPU的性能，有可能还不如几条线程运行来得快（因为上下文切换的少呗）。
总结：时间片设的太短，会导致过多的线程切换，降低CPU效率，太长可能引起对短的交互请求响应变差。将时间片设为100毫秒通常是一个比较合理的折中。

在CPU死机的情况下，还能kill这个进程，应该就是因为RR调度。

●03.什么是进程和线程
1）进程是操作系统在运行时进行资源分配和调度的最小单位。系统给进程分配CPU、磁盘io、内存等资源
2）线程是CPU调度的最小单位，必须依赖于进程而存在。
3）打个比喻就是进程是个盒子，线程是放进去的物品。启动进程的同时，肯定会创建一个线程。多个线程可以共享进程的资源。

一个应用一个进程在Linux中最多可以启动1000个线程，window上最多启动2000个。
指定CPU跑某个线程、进程，需要调用Linux的内核来操作，java做不到，必须用C语言去写。

●04.并行和并发
1）并行是是同时运行，和处理器是几线程的有关，如四核心八线程，就是并行8个线程。
2）并发是单位时间内能处理的线程数量。举例来说就是一条路每小时通行车辆的最大数量。
并发是通过时间片轮转机制来实现并发，一秒钟执行多少个时间片就是这个核心的并发数，超线程的话就是2倍。

●05.高并发编程的意义，好处和注意事项。
优点：
充分利用CPU的资源；
下载更快， 页面加载更快， 也更流畅， 能更快响应用户；
可以使代码模块化，异步化，简单化。

缺点：
容易产生线程间同步问题；
容易死锁；
线程太多会将服务器资源耗尽，造成死机宕机。

线程启动缺省分配一兆的内存。

●06.Java天生就是多线程的，一个main启动了六个线程
1）Monitor Ctrl-Break  监控Ctrl-break中断的信号
2）Attach Listener  内存Dump，线程dump，类信息统计，获取系统属性等
3）Signal Dispatcher  分发处理发送个JVM信号的线程
4）Finalizer  调用对象finalize方法的线程，可能会被Reference Handler提前杀掉，造成资源回收不了
5）Reference Handler 清除Reference的线程
6）main  主线程，程序入口。

●07.线程的新建方法：三种
1）直接实现Thread。
2）实现Runnable，交给Thread去执行。
3）实现Callable，交给FutureTask包装，再交给Thread执行。
4）无论Runnable还是Callable都只是一个接口而已，内中方法也只是一个可以执行的普通方法而已。线程只有Thread一种。

●08.FutureTask就是对具体的Runnable、Callable任务的执行、取消，查询是否完成，获取结果。
1）cancel(boolean):Boolean  取消任务
2）isCancel():boolean  是否取消
3）isDone():boolean  是否完成
4）get():V  获取返回结果，此方法会阻塞，直到任务返回结果
5）get(long,TimeUnit):V

FutureTask -> RunnableFuture -> Runnable,Future
done(): void 完成就会调用

●09.Thread
1）start()  启动线程，不可重复执行。只有执行了此方法，才实现了真正意义上的启动线程。放入就绪队列。
2）interrupt()  标记中断，Thread内不检测的话，就没用
3）isInterrupted() 对interrupt的检测，是否中断
4）static interrupted() 也是对interrupt的检测，但是为true时，执行了此方法，会将中断标记重置为false。
5）run()  执行任务，实现业务逻辑的地方，和普通方法无区别。
6）join() 插队，可以无限插队
7）yield() 让出CPU，进入就绪队列（可运行状态，让出时间不确定），等待CPU分配时间片。不会释放锁。
而且让出后有可能又会被立刻选中进入执行状态，因为线程切换（上下文切换），其他线程都需要重新加载。
8）sleep() 让出CPU，进入阻塞状态。不会释放锁。

等待与通知，是线程调用所在对象的wait与notify/notifyAll。只能在synchronized修饰的方法内使用。
9）wait()  等待通知或被中断才会返回，让出CPU，释放锁。
9）wait(long)  等待通知或被中断才会返回，让出CPU，释放锁。超时返回
9）wait(long,int纳秒)  等待通知或被中断才会返回，让出CPU，释放锁。超时返回，
10）notify  通知一个在对象上等待的线程，唤醒的是哪条线程不确定，只有一个线程的时候无所谓。
10）notifyAll  通知所有在对象上等待的线程
推荐wait和notifyAll。

sleep与wait都会抛出InterruptException，线程在阻塞状态下，依然会检查中断标记，当中断标记为true时，就会抛出异常，同时将中断标记重置为false。如要确实结束，需要在catch里在执行一次interrupt()方法。

处于死锁状态下的线程无法被中断。
线程的优先级，由于系统原因，不能保证。

●10.threadLocal 线程隔离，独有变量设定，需要static final修饰。如果不是唯一的，那new的时候对象本身的变量就是独有的，就没意义了。
1）initialValue() 初始化变量，默认为空。
2）get()
3）set()  值变化后，需重新设置，否则还是 初始值。
4）remove() 回收当前线程的局部变量。即使不回收，线程结束后也将自动被垃圾回收。他的作用只是加快了内存回收的速度。

锁的使用
●01.synchronized：对象锁和类锁
1）对象锁：就是锁对象本身实例或者其他对象实例。
2）类锁：锁的是对象的class对象，是用static修饰的方法。锁定一个静态对象，锁的是这个静态对象，而不是它的class对象（类似类锁）
3）因为一个类的class对象在类加载器中是唯一的，类的对象实例可以有多个，所以不同的对象锁是互不干扰的，类锁是唯一的。
4）类锁其实也是对象锁，只是他是唯一的，而且锁的是class对象。所以叫类锁吧。

●02.synchronized的缺点：
1）一旦开始获取锁，是不能中断的，也不提供超时获取锁的机制。

●03.Lock：显示锁
1）lock()
2）lockInterruptibly() 可中断的获取锁，在锁的获取过程中可以中断当前线程的阻塞，会抛出interruptedException
3）tryLock()  尝试非阻塞的获取锁，调用该方法后立刻返回，能够获取返回true
4）tryLock(long)   超时获取锁，有三种情况：
当前线程在超时时间内获得了锁
当前线程在超时时间内被中断
超时时间结束，返回false。
5）unLock()
6）newCondition() 等待和通知机制

●04.常用锁 synchronized ReentrantLock ReentrantReadWriteLock（ReadWriteLock读写锁，两把锁）
锁的种类：
排它锁：自己获得锁的时候，不许其他线程使用。
可重入锁：允许自身多次调用，如递归方法
锁的公平与非公平：获取锁的时候，涉及到线程的挂起与唤醒，也就是上下文切换，公平会唤醒下一个排队的线程，非公平是队列上谁醒着，谁上。

synchronized   排它、可重入
ReentrrantLock 排它、可重入、支持公平与非公平，默认非公平。
ReentrantReadWriteLock 读的时候可以多条线程一起读，但是不能写；写的时候，只能一个线程写，也不能读。

●05.Condition 显示锁Lock对应的等待与通知。
Condition与lock对应
wait与synchronized对应
1）await() 等待
2）awaitUninterruptibly()
3）await(long,TimeUnit)
4）awaitNanos(long)
5）awaitUntil(date)
5）signal() 通知单个，推荐使用的，因为可以定点唤醒。
5）signalAll() 多通知全部

线程池原理
●01.线程池的好处
1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2）提高响应速度。因为线程已创建，可以立即执行新加入的任务，不过满了，就得等着了。
3）提高线程的可管理性。线程启动内存缺省一兆大小，启动太多，不仅会消耗系统资源，还降低系统的稳定性，使用线程池进行统一分配、调优和监控。

●02.JDK中的线程池的创建
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)
1）corePoolSize    默认核心线程的数量，默认是未创建的。但是当线程池执行了prestartAllCoreThreads()方法后，会提前创建并启动所有核心线程。
2）maximumPoolSize 允许最大线程的数量，当队列workQueue满了之后，继续提交任务，就会创建新的线程。
3）keepAliveTime   默认来说是非核心线程的存活时间。核心线程创建后，一直存活。
4）unit            keepAliveTime的时间单位
5）workQueue       线程队列，它是阻塞队列。核心线程都在执行任务时，继续提交的任务就会进入阻塞队列中等待。通过workQueue，线程池实现了阻塞功能。
6）threadFactory   创建线程的工厂
7）handler         饱和策略，默认是抛出异常。最大线程满载时还提交任务，就会抛出。

●03.线程池的工作机制
1）生产者提交任务，默认最大核心线程数未达到最大时，创建新线程执行任务。
2）默认核心线程达到最大时，开始往workQueue阻塞队列中添加。
3）workQueue也达到最大时，开始创建新的线程，直到达到支持的最大线程数为止。
4）如还有任务提交，会执行线程池的饱和策略RejectedExecutionHandler，默认的是直接抛出异常。

execute(Runnable)无返回值，需要返回值的话，用submit(Runnable)

●04.什么是队列？
队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。
进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。
队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早入队的元素才能最先出队，故队列又称为先进先出线性表。
FIFO--first in first out

●05.阻塞队列
1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。
2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。

阻塞队列产用于生产者和消费者的场景。生产者插入，消费者取出。
常用方法    抛出异常    返回特殊值   一直阻塞
插入方法    add()       offer(e)    put(e)
移除方法    remove()    poll()      take()
检查方法    element()   peek()      不可用

抛出异常：
当队列满时，再插入，会抛出IllegalStateException("QueueFull")异常。
当队列空时，获取会抛出noSuchElementException异常。

返回特殊值：
插入时会返回元素是否插入成功。
取出时，没有会返回null。

一直阻塞：
当队列满时，生产者线程put元素时，队列会一直阻塞生产者线程，直到队列可用或响应中断退出。
当队列空时，消费者线程take元素，队列会阻塞消费者线程，直到队列不为空。

常用阻塞队列：
ArrayBlockingQueue：一个有数组结构组成的有界阻塞队列。主要
LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。主要
LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。
LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
DelayQueue：一个使用优先级队列实现的无界阻塞队列。
PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。
SynchronousQueue：一个内部只包含一个元素的阻塞队列。

●06.ThreadFactory 创建线程的工厂
Executors静态工厂里默认的threadFactory线程的命名规则是：pool-数字-thread-数字

●07.饱和策略 RejectedExecutionHandler
阻塞队列满了，工作线程满载，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了四种策略。
1）AbortPolicy：直接抛出异常，默认策略。
2）CallerRunsPolicy：用生产者自身线程来执行任务。
3）DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务，并执行当前任务。
4）DiscardPolicy：直接丢弃该任务。
5）自己实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。

●08.合理配置线程池
需要分析任务特性。
1）任务的性质：CPU密集型（计算相关）；IO密集型（IO流）；混合型
2）任务的优先级：高中低
3）任务的执行时间：长中短。
4）任务的依赖性：是否依赖其他系统资源，如本地文件，数据库。

CPU密集型：计算相关，所以快，应该配置尽可能少的线程，防止线程切换造成的资源浪费。配置：cpu核心数+1
IO密集型：涉及io操作，执行时间一般较长，可以多配置一些。通常：2*cpu核心数+1
混合型：两者执行时间相差不大那就拆分开，变成两个任务去执行，一定比两者串行要快；相差过大，那就无所谓了。

之所以加1，是防止有线程阻塞后，CPU可以立马获取下一个等待线程。

Runtime.getRuntime().availableProcessors() 当前可用的逻辑核心数

●09.AsyncTask
1）onPreExecute()  准备工作，如显示进度条可以在此初始化。
2）doInBackground(params)  异步任务，只有此方法是执行在子线程中，在onPreExecute之后立即执行。
3）onProgressUpdate(values)  可在此设置进度条的更新，需要在doInBackground()中调用publishProgress()方法
4）onPostExecute(result)  异步任务完成后返回的结果。

AsyncTask创建的其实只是一个任务，然后把这个任务加入到任务池，之后再转到线程池中。内部的任务池和线程池可以说都是饿汉模式的单例，类加载的时候就已经确定了。

10.0系统下AsyncTask的实现过程：
第一步：创建AsyncTask，并把任务加入任务池中；
new AsyncTask()时，新建了一个Callable，一个FutureTask，在execute("")时，把FutureTask放入一个任务池中，其中会执行onPreExecute()方法。
如下：
mStatus = Status.RUNNING;//变为运行状态，之前有状态检查，如果已经运行了，会抛出异常，所以execute只能调用一次。
onPreExecute();//执行准备方法
mWorker.mParams = params;//为Callable设置参数。
exec.execute(mFuture);//把FutureTask加入任务池中，开始执行。

第二步：放入任务池后，开始轮循取出任务，交给线程池，开始执行；
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
此成员变量是个任务池，内部有一个双端队列ArrayQueue（最大16个元素）；
在execute()方法中通过offer将任务加入队列中，紧接着调用scheduleNext()方法，通过poll取出任务加入线程池执行。

第三步：开始调用call方法
然后开始执行Callable中的call方法，其中会调用doInBackground(params)方法。
完成后返回的结果，会在在FutureTask中的done方法中调用get获取，通过postResultIfNotInvoked(result)方法传递给Handler；
在handlermessage方法中调用AsyncTask的finish()方法返回result，其中会调用onPostExecute(result)方法。会在这个方法中检查是否已取消。

其中有乐观锁机制，待研究。

public static final Executor THREAD_POOL_EXECUTOR;
此成员变量就是线程池，10.0系统下，此线程池内的队列使用的是SynchronousQueue，一个只有一个元素的阻塞队列，
一个核心线程，20的最大线程数，一个元素的阻塞队列，加一个容器16的数组一共最大可添加37个任务，之后再添加会执行饱和策略。

10.0系统下的饱和策略是再创建一个线程池，来容纳多出来的任务，此线程池采用了链表LinkedBlockingQueue，默认上限，默认开启5个核心线程，最大也只开5个。

●10.AsyncTask的优缺点
优点：AsyncTask是一个轻量级的异步任务处理类，轻量级体现在：使用方便，代码简洁，而且整个异步任务可以通过cancel()进行控制
缺点：不适用于处理长时间的异步任务，一般这个任务过程最好控制在几秒以内，如果长时间的异步任务就需要考虑多线程的控制问题，当处理多个异步任务时，UI更新变得困难。

●11.Handler的优缺点
优点：代码结构清晰，容易处理多个异步任务。
缺点：当有多个异步任务时，由于要配合Thread或Runnable，代码可能会稍显冗余。

总结：AsyncTask不失为一个非常好用的异步任务处理类，只要不是频繁大量对UI进行更新，可以考虑使用。
而Handler在处理大量UI更新时可以考虑使用。

●12.CAS，（乐观锁机制）。
什么是原子操作？如何实现原子操作？
原子操作就是顺序操作，不能交叉，只有执行完A，才执行B，或者反过来。
锁机制就保证了原子操作。

实现原子操作还可以使用当前处理器支持的CAS()指令;
每一个CAS操作过程都包含三个运算符，内存地址V，一个期望值A（旧值），新值B，如果内存地址上放的值等于A，则将地址上的值赋为新值B，否则不作操作。
循环CAS，就是一个循环里不断做CAS操作直到成功。
加上Volatile变量的特性就可实现基于原子操作的线程安全。

JVM虚拟机的原理
●01.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

