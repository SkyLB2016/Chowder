享学课堂

加油学习
专用名词：
缺省：就是默认
实参：实际参数，类中定义的，可以是常量，变量，表达式，函数等，还有类型（泛型结构中的T）。
形参：形式参数，就是方法后边的参数名，用来在方法被调用时，接收传进来的实参具体的值。
原生类型：就是基本数据类型。
Java中的泛型
●01.泛型的好处，或者说为什么需要泛型？
1）适用于多种数据类型执行相同的代码。
2）泛型中的类型在使用时指定，不需要强制类型转换。

●02.泛型类、泛型接口、泛型方法，可以理解成“参数化类型”，也就是用 类型形参接收类型实参。
泛型的本质是为了参数化类型（在部创建新的类型的情况下，通过泛型指定的不同类型来控制形参的具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法、

●03.泛型都是带<>才是泛型类、泛型接口、泛型方法，通常使用 T、E、K、V，可以多个参数，当然也可以是全拼，如AsyncTask就是这么用的。
其中泛型方法在泛型类和普通类中都可以使用。

●04.实现泛型接口的类，有两种方法：除了泛型参数，其他的和普通类没区别。
1）可继承时不传入泛型实参，也就是继续保持T，但new时必须指定具体类型。如list创建，不指定那就是Object
2）继承是直接传入泛型实参。

●05.限定类型变量
1）T extends XXX：T代表应该绑定的子类型，XXX表示这个类型的超类上限；
extends左右都允许有多个，如：
T,V extends Serializable&Comparable
但是在限定类型中，只能有一个类，但可以多个接口，有类时，则类必须在第一个。

●06.泛型中的约束和局限性
1）不能用八种基本类型实例化参数，必须是换成八种类型的包装类才行。
2）不能用 list instanceof List<String>做比，因为java中的泛型是伪泛型，包装的时候后边的类型会被擦除，然后转成object或者继承的超类。
3）list通过getclass()方法获取的类名，是不带后边类型参数的。
4）不能在静态域或方法中使用，泛型是对象创建时才初始化，而静态域与方法是在new之前就创建好的。但是本身就是泛型方法就可以，如：
private static <T> T getInstance(){};
5）不能创建参数化类型的数组，也就是不带就行了
ApiResponse<String>[] response = new ApiResponse<String>[2]; //不可以
ApiResponse<String>[] response = new ApiResponse[2];//可以
6）不能实例化类型变量，也就是不能new T()
7）不能捕获继承Exception/Throwable的泛型类实例，但是可以抛出，也就是throws T
8）泛型类实例化时，前后的类型必须统一，即使是继承关系的也不行。

●07.通配符类型，只在方法中使用，不能在类中使用，比较懵逼，可以从是否能安全转型来理解。
1）? extends XX:主要用于安全的访问数据，可以访问X及其子类型，并且不能写入非空数据
Generic<? extends A> str=new Generic<>();
str.setData(new AB());//不能这样设置，传入的子类具体是哪个是不确定的。
str.getData();//可以获取
2）？super XX:主要用于安全的写入数据，可以写入X及其子类。
Generic<? super AB> str=new Generic<>();
str.setData(new A());//不能这样设置
str.setData(new AB());//只能是他本身或其子类
str.getData();//可以获取

3）无限通配符：?，表示对类型没有限制，当成object理解就行了，调用getFist返回的是object类型，setFist不能被调用。

●08.虚拟机是如何实现泛型的？
在C#中，List<Integer> 与List<String>是两个不同的类型，在系统运行初期生成，有自己的方法和数据，这种实现成为类型膨胀，基于这种方法实现的泛型成为真泛型。
java语言中的泛型不一样，他只在程序源码中存在，在编译后的字节码中，就已经替换为原来的原生类型object（Raw Type，也称为裸类型），并且在修昂硬的地方插入了强转代码，因此List<Integer> 与List<String>就是同一个类，
所以泛型技术实际上是java语言的一颗语法糖，JAVA语言中的泛型实现方法为类型擦除，基于这种方法实现的泛型成为伪泛型。
所以将一段java代码编译成class文件后，再用字节码反编译工具进行反编译后，泛型就都不见了，程序又变回了java泛型出现前的写法，泛型都变回了原生类型。
限定列表是接口和类的，默认取第一个类（接口）作为原生类型。

●09.是不是同一个方法，jdk是靠返回类型，方法名，参数三者来判断的，但编译工具只判断方法名和参数。

●10.由于类型的擦除倒是泛型类是一样的，所以JCP组织对虚拟机规范做出了相应的修改，引入了注入Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题。
Signature是其中最重要的一项属性，他的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确的识别Signature参数。
另外，从Signature属性我们还可以得出结论，擦除仅仅只是对code属性中的字节码进行擦除，但是元数据还是保存了泛型信息，这也是我们能通过反射手段去的参数化类型的根本依据。


反射原理以及动态代理模式
●01.反射
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）
