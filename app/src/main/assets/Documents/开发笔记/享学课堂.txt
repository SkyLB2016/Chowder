享学课堂

加油学习
专用名词：
缺省：就是默认
实参：实际参数，类中定义的，可以是常量，变量，表达式，函数等，还有类型（泛型结构中的T）。
形参：形式参数，就是方法后边的参数名，用来在方法被调用时，接收传进来的实参具体的值。
原生类型：就是基本数据类型。

Java中的泛型
●01.泛型的好处，或者说为什么需要泛型？
1）适用于多种数据类型执行相同的代码。
2）泛型中的类型在使用时指定，不需要强制类型转换。

●02.泛型类、泛型接口、泛型方法，可以理解成“参数化类型”，将类型作为实参传入，形参接收；
都必须带<>，通常使用 T、E、K、V，可以多个参数，当然也可以是全拼，如AsyncTask就是这么用的。
其中泛型方法在泛型类和普通类中都可以使用。
泛型的本质是为了参数化类型（在不创建新类的情况下，通过泛型指定的不同类型来控制形参的具体限制的类型）。
也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法、

●03.实现泛型接口的类，有两种方法：除了泛型参数，其他的和普通类没区别。
1）可继承时不传入泛型实参，也就是继续保持T，但new时必须指定具体类型。如list创建，不指定那就是Object
2）继承是直接传入泛型实参。

●04.限定类型变量
1）T extends XXX：T代表应该绑定的子类型，XXX表示这个类型的超类上限；
extends左右都允许有多个，限定类型书写规则为：类&接口&接口，有类，则类必须在最前，且只能有一个类，接口可以多个。
T,V extends Serializable&Comparable
逗号分隔是不继承的，只是VDE继承。

●05.泛型中的约束和局限性
1）不能用八种基本类型实例化参数，必须是换成八种类型的包装类才行，因为基本类型不是对象。
2）泛型类实例化时，前后的类型必须统一，即使是继承关系的也不行。
3）不能用 list instanceof List<String>做比，因为java中的泛型是伪泛型，包装的时候后边的类型会被擦除，然后转成object或者继承的超类。
4）不能实例化类型变量，也就是不能new T()
5）list通过getclass()方法获取的类名，是不带后边类型参数的。
6）不能在静态域或方法中使用，泛型是对象创建时才初始化，而静态域与方法是在new之前就创建好的。但是本身就是泛型方法就可以，如：
private static <T> T getInstance(){};
因为调用的同时类型就确定了，所以可以使用。
7）不能创建参数化类型的数组，但是不带就行了，不过不推荐，还是用list比价好。
ApiResponse<String>[] response = new ApiResponse<String>[2]; //不可以
ApiResponse<String>[] response = new ApiResponse[2];//可以
8）泛型类不能继承Exception/Throwable，这么写是不行的：A<T> extends Exception;
泛型可以继承Exception，例：T extends Exception，但是不能捕获也就是不能catch到继承Exception/Throwable的泛型类实例，但是可以抛出，也就是throws T

●06.通配符类型，只在方法参数以及成员变量中使用，不能在类中使用，可以从是否能安全转型来理解。
1）无限通配符：?，表示对类型没有限制，当成object理解就行了，调用getFist返回的是object类型，setFist不能被调用。
2）? extends XX:规定了表示传递个方法的参数，必须是XX的子类，主要用于安全的访问数据，可以访问X及其子类型，并且不能写入非空数据
public void print(GenericType<? extends XX> type){}//传入的参数只能是XX以及他的子类
GenericType<? extends XX> type;

GenericType<? extends XX> type=new GenericType<>();
type.setData(new Child());//不能这样设置，传入的子类具体是哪个是不确定的。
type.getData();//可以获取

3）？super XX:必须是xx的超类，主要用于安全的写入数据，可以写入X及其子类。
public void print(GenericType<? supper XX> type)//传入的参数只能是XX以及他的超类
GenericType<? supper XX> type;

GenericType<? super XX> type=new GenericType<>();
type.setData(new XXX());//不能设置为XX的父类，和作为参数时，不一样啊，这个，，，没办法，只能记住了。
type.setData(new AB());//只能是他本身或其子类，
Object data=type.getData();//可以获取，但获取的是object对象

或者可以这么理解，set的时候因为XX及其子类可能存在父类没有的方法，所以父类不能安全转型成XX，也有可能这个类本身就是继承父类的其他类，所以不让设置没所以取得时候，取出来的是Object对象。

●08.虚拟机是如何实现泛型的？
在C#中，List<Integer> 与List<String>是两个不同的类型，在系统运行初期生成，有自己的方法和数据，这种实现成为类型膨胀，基于这种方法实现的泛型成为真泛型。
java语言中的泛型不一样，他只在程序源码中存在，在编译后的字节码中，就已经替换为原来的原生类型object（Raw Type，也称为裸类型），并且在合适的地方插入了强转代码，因此List<Integer> 与List<String>就是同一个类，
所以泛型技术实际上是java语言的一颗语法糖，JAVA语言中的泛型实现方法为类型擦除，基于这种方法实现的泛型成为伪泛型。
所以将一段java代码编译成class文件后，再用字节码反编译工具进行反编译后，泛型就都不见了，程序又变回了java泛型出现前的写法，泛型都变回了原生类型。
限定列表是接口和类的，默认取第一个类（接口）作为原生类型。

●09.是不是同一个方法，jdk是靠返回类型，方法名，参数三者来判断的，但编译工具只判断方法名和参数。

●10.由于类型的擦除导致泛型类是一样的，所以JCP组织对虚拟机规范做出了相应的修改，引入了注入Signature、LocalVariableTypeTable等新的属性用于解决伴随泛型而来的参数类型的识别问题。
Signature是其中最重要的一项属性，他的作用就是存储一个方法在字节码层面的特征签名，这个属性中保存的参数类型并不是原生类型，而是包括了参数化类型的信息，修改后的虚拟机规范要求所有能识别49.0以上版本的Class文件的虚拟机都要能正确的识别Signature参数。
另外，从Signature属性我们还可以得出结论，擦除仅仅只是对code属性中的字节码进行擦除，但是元数据还是保存了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。


反射原理以及动态代理模式
●01.反射 Reflection
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。
反射是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection Api取得任何类的内部信息，并能直接操作人以对象的内部属性及方法。
发射机制主要提供了一下功能：
1）在运行时构造任意一个类的对象
2）在运行时获取任意一个类所具有的成员变量和方法
3）在运行时调用任意一个对象的方法或属性。

●02.Class类，也是一个类，他的作用是用来描述类的，也就是对类的封装，一个类可以有多个实例对象，但是只会有一个class实例对象，这个class对象里包含了这个对象所对应的类的类名，属性，方法，构造器，接口信息等。
获取class实例的三种方式
1）通过类名获取：类名.class
2）通过对象获取：对象引用名.getclass()
3）通过全类名获取：Class.ForName(全类名)

●03.class常用方法：
1）static Class forName(String name) 返回指定类名name的class对象
2）Object newInstance() 嗲用缺省构造函数，返回该class对象的一个实例
3）Object newInstance(Object[] args) 调用当前格式构造函数，返回该class对象的一个实例
4）getName() 返回此Class对象所表示的实体（类、接口、数据类、基本类型或Void）名称
5）Class getSuperClass() 返回当前Class对象的父类的Class对象
6）Class[] getInterFaces() 返回当前Class对象所有的接口
7）ClassLoader getClassLoader() 返回该类的类加载器

获取构造器：需要转成指定对应实例的泛型
getConstructors() 全部构造器
getConstructor(Class<?> params) 单个构造器，以及对应的参数

获取方法
getMethods()  获取所有的public方法，包含父类的
getDeclaredMethods() 获取自身所有-的方法，包含私有的。
getDeclaredMethod() 获取指定方法

获取属性
getFields() 获取所有的public属性，包含父类的
getDeclaredFields() 获取自身的所有属性
getDeclaredField() 获取指定属性

setAccessible() 访问私有的

●04.代理模式，分为静态代理，与动态代理（Proxy InvocationHandler）
一个接口，实现类，包含实现类的代理类（同样继承接口，在相同的方法内调用实现类的方法），访问者。
静态代理就是标准的一条链下来。缺点是扩展能力差，可维护性差
动态代理就是使用时再创建代理类和实例。
优点是：由于其中代理类是使用代码自动生成，减少了重复类的创建。
缺点是：由于使用反射，所以效率比较低。
应用场景局限，因为java的单继承特性（每个代理类都集成了Proxy类），即只能针对接口创建代理类，不能针对类创建代理类。
Proxy是用来创建动态代理类的类。
InvocationHandler是给动态代理类是给动态代理类实现的，负责处理被代理对象的操作的。

类的完整生命周期：java源文件->java字节码->class对象->实例对象->卸载；周而复始。

多线程与线程池
多核心：单芯片多处理器（Chip Multiprocessors，简称CMP），是有美国斯坦福大学提出的，其思想是将大规模并行处理器中的SMP（对称多处理器）集成到同一芯片内，各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向，成为并行处理。
多线程：Simultaneous Multithreading。简称SMT，SMT可通过复制处理器上的结构状态，让同一个处理器上的多个线程同步执行并共享处理器的执行资源，可最大限度地实现宽发射、乱序的超标量处理，提高处理器运算部件的利用率，缓和由于数据相关或Cache未命中带来的访问内存延时。

●01.CPU的核心数与线程的关系：
一般一个核心对应一个线程，但是拥有超线程的核心可以一对二。

●02.CPU的时间片轮转机制，是一种最古老、最简单、最公平且使用最广的算法，也称为RR调度。
每个线程被分配一个时间段，称作他的时间片，即该线程允许运行的时间。
也就是把CPU的运行时间切片，如一秒切成10份，100份。不同的系统，时间片大小不一样。

时间到还在运行，CPU将被剥夺，所以sleep之类的阻塞代码执行时，虽然锁没有释放，但是CPU已经去执行别的线程了。
RR调度中损耗时间最大的可能就是线程切换（上下文切换），从一个线程切换到另一个，需要保存和装入寄存器值及内存映像，更新各种表格和队列等，一次大概消耗20000个CPU时间周期。1+1就相当于一个时间周期。
线程过多就会频繁切换线程，造成大量的上下文切换，会大量浪费CPU的性能，有可能还不如几条线程运行来得快（因为上下问切换的少呗）。
总结：时间片设的太短，会导致过多的线程切换，降低CPU效率，太长可能引起对短的交互请求响应变差。将时间片设为100毫秒通常是一个比较合理的折中。

在CPU死机的情况下，还能kill这个进程，应该就是因为RR调度。
●03.什么是进程和线程
1）进程是操作系统在运行时进行资源分配和调度的最小单位。系统给进程分配CPU、磁盘io、内存等资源
2）线程是CPU调度的最小单位，必须依赖于进程而存在。
3）打个比喻就是进程是个盒子，线程是放进去的物品。启动进程的同时，肯定会创建一个线程。多个线程可以共享进程的资源。

一个应用一个进程在Linux中最多可以启动1000个线程，window上最多启动2000个。
指定CPU跑某个线程进程，需要调用Linux的内核来操作，java做不到，必须用C语言去写。

●04.并行和并发
1）并行是处理器上是几核心几线程，如四核心八线程，就是并行8个线程。
2）并发是单位时间内能处理的线程数量。举例来说就是一条路每小时通行车辆的最大数量。
并发是通过时间片轮转机制来实现并发，一秒钟执行多少个时间片就是这个核心的并发数，超线程的话就是2倍。

●05.高并发编程的意义，好处和注意事项。
1）葱粉利用CPU的资源，
下载更快，页面加载更快，也更流畅，这样也就加快响应用户时间，
可以使代码模块化，异步化，简单化。
2）容易产生线程间同步问题，
容易死锁，
线程太多会将服务器资源耗尽，造成死机宕机。
线程启动缺省分配一兆的内存。
RR调度在切换线程时（从一个线程切换到另一个，需要保存和装入寄存器值及内存映像，更新各种表格和队列等），俗称《上下文切换》，一次大概消耗20000个CPU时间周期。1+1就相当于一个时间周期。
线程过多就会频繁切换线程，造成大量的上下文切换，会大量浪费CPU的性能，有可能还不如几条线程运行来得快（因为上下问切换的少呗）。

●06.Java天生就是多线程的，一个main启动了六个线程
1）Monitor Ctrl-Break  监控Ctrl-break中断的信号
2）Attach Listener  内存Dump，线程dump，类信息统计，获取系统属性等
3）Signal Dispatcher  分发处理发送个JVM信号的线程
4）Finalizer  调用对象finalize方法的线程，可能会被Reference Handler提前杀掉，造成资源回收不了
5）Reference Handler 清除Reference的线程
6）main  主线程，程序入口。

●07.线程的新建方法：三种
1）直接实现Thread。
2）实现Runnable，交给Thread去执行。
3）实现Callable，交给FutureTask包装，再交给Thread执行。
4）无论Runnable还是Callable都只是一个接口而已，内中方法也只是一个可以执行的普通方法而已。线程只有Thread一种。

●08.FutureTask就是对具体的Runnable、Callable任务的执行进行取消，查询是否完成，获取结果。
1）cancel(boolean):Boolean  取消任务
2）isCancel():boolean  是否取消
3）isDone():boolean  是否完成
4）get():V  获取返回结果，此方法会阻塞，直到任务返回结果
5）get(long,TimeUnit):V

FutureTask -> RunnableFuture -> Runnable,Future

●09.Thread
1）start()  启动线程，不可重复执行。只有执行了此方法，才实现了真正意义上的启动线程。
2）interrupt()  标记中断，Thread内不检测的话，就没用
3）isInterrupted() 对interrupt的检测，是否中断
4）static isInterrupted() 也是对interrupt的检测，但是为true时，执行了此方法，会将中断标记重置为false。
5）run()  执行任务，实现业务逻辑的地方，和普通方法无区别。
6）join() 插队，可以无限插队
7）yield() 让出CPU，进入就绪队列（可运行状态），等待CPU分配时间片。不会释放锁
8）sleep() 让出CPU，进入阻塞状态。不会释放锁。
9）wait()  让出CPU，释放锁。
10）notify/notifyAll，等待与通知，推荐wait和notifyAll。

处于死锁状态下的线程无法被中断。

线程间的共享和协作
●01.synchronized：对象锁和类锁
1）对象锁：就是锁对象本身实例或者其他对象实例
2）类锁：锁的是对象的class对象或者一个静态方法。
3）因为一个类加载器中的class是唯一的，类的对象实例可以有多个，做不同的对象锁是互不干扰的，类锁是唯一的。
4）类锁其实也是对象锁，只是他是唯一的，而且锁的是class对象。所以叫类锁吧。

●02.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

●0.
1）
2）
3）
4）
5）

