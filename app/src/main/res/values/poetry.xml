<resources>
    <string name="suibi">
        随笔\n
        teach yourself programming in ten years\n
        十年编程\n
        十年的寒窗苦读，日日夜夜的秉烛夜读，43800个小时的投入，换来状元及第的可能，何谓坚持，此即谓坚持。\n
        穷养儿富养女，养的是儿子的自信与独立，养的是女儿的知性与高雅
    </string>
    <string name="renwu">
        待完成任务\n
        (1)文本搜索，算数，目录筛选拆分\n
        (2)拼图拉伸优化\n
        (3)位移运算\n
        (4)通知pendingIntent，notification\n
        (5)重构apputils\n
        (6)整理笔记顺序\n
        (7)插件拆分第九章第九节，第四小节\n
        (8)第九章第十一节h5篇安卓片上面应用的技术分析。\n
        (9)monkey\n
        (10)插件拆分第九章第九节，第四小节。\n
        (11)第九章第十一节h5篇安卓片上面应用的技术分析。\n
        (12)总结知识框架\n
        (13)annotation使用\n
        (14)Percent 百分比使用：com.android.suport:percent:23.2.0，包含PercentFrameLayout，PercentRelativeLayout，PercentLayoutHoper\n
        (15)Design兼容库\n
        (16)TCP/IP，URLConnection，webView使用，疯狂讲义第十三章\n
        (17)加密，rsa\n
        ()\n
    </string>
    <string name="yingyu">
        英语笔记\n
        adopt\n
        　英 [əˈdɒpt] 美 [əˈdɑ:pt]\n
        　vt. 收养;采用，采取，采纳;正式接受，接受;批准\n
        article\n
        　英 [ˈɑ:tɪkl] 美 [ˈɑ:rtɪkl]\n
        　n. 物品;（报章杂志中的）文章，论文;条款;[语] 冠词\n
        　vt. 使受协议条款的约束;以协议（或契约）约束;订约将…收为学徒（或徒弟）;定约雇用\n
        　vi. 进行控告，提出罪状（或指责）(against);签订协议\n
        calculate\n
        　英 [ˈkælkjuleɪt] 美 [ˈkælkjəˌlet]\n
        　vt. vi. 计算;估计;打算，计划;旨在\n
        　vt. 预测，推测\n
        caught\n
        　英 [kɔ:t] 美 [kɔt]\n
        　v. 引起;赶上( catch的过去式和过去分词 );接住;看见\n
        crash\n
        　英 [kræʃ] 美 [kræʃ]\n
        　v. 碰撞;使发出巨响;暴跌;睡觉\n
        　n. 崩溃;碰撞;碰撞声;暴跌\n
        　adj. 应急的;速成的\n
        decode\n
        　英 [ˌdi:ˈkəʊd] 美 [ˌdi:ˈkoʊd]\n
        　vt. 译（码），解（码）;分析及译解电子信号\n
        default\n
        　英 [dɪˈfɔ:lt] 美 [dɪˈfɔlt]\n
        　vi. 未履行任务或责任;受传唤时未出庭;由于不到庭而败诉;弃权\n
        　vt. 未履行，拖欠;未参加或完成（例如，比赛）;[法]因未到庭而败（诉）\n
        　n. 未履行，拖欠;[法]未到庭;弃权;[计] 缺省，默认\n
        executor\n
        　英 [ɪgˈzekjətə(r)] 美 [ɪɡˈzɛkjətɚ, ˈɛksɪˌkjutɚ]\n
        　n. 遗嘱执行人;执行者;实行者\n
        expire\n
        　英 [ɪkˈspaɪə(r)] 美 [ɪkˈspaɪr]\n
        　vi. 期满;文件、协议等（因到期而）失效;断气;逝世\n
        least 英 [li:st] 美 [list]\n
        　adj. 最小的;最少的（ little的最高级）;最不重要的，地位最低的\n
        　adv. 最少，最小\n
        　n. 最小;最少量\n
        logistics\n
        　英 [ləˈdʒɪstɪks] 美 [loˈdʒɪstɪks]\n
        　n. 物流;后勤;逻辑学;组织工作\n
        observable\n
        　英 [əbˈzɜ:vəbl] 美 [əbˈzɜ:rvəbl]\n
        　adj. 观察得到的，应遵守的，应庆祝的\n
        original\n
        　英 [əˈrɪdʒənl] 美 [əˈrɪdʒənəl]\n
        　adj. 原始的;最初的;独创的;新颖的\n
        　n. 原件;原文;原型;怪人\n
        receiver\n
        　英 [rɪˈsi:və(r)] 美 [rɪˈsivɚ]\n
        　n. 接收器;接受者，收款员;无线电接收机;（破产公司的）官方接管人\n
        recently\n
        　英 [ˈri:sntli] 美 [ˈrisṇtlɪ]\n
        　adv. 近日;新近;最近，近来;不久以前\n
        subject\n
        　英 [ˈsʌbdʒɪkt] 美 [ˈsʌbdʒekt]\n
        　n. 主题，话题;学科，科目;[哲]主观\n
        　adj. 须服从…的;（在君主等）统治下的\n
        v. 提供，提出;使…隶属\n
        synchronized\n
        　英 [ˈsɪŋkrənaɪzd] 美 [ˈsɪŋkrənaɪzd]\n
        　同步的\n
        tracker\n
        　英 [ˈtrækə(r)] 美 [ˈtrækər]\n
        　n. 追踪者，追踪系统，纤夫\n
        velocity\n
        　英 [vəˈlɒsəti] 美 [vəˈlɑ:səti]\n
        　n. 速率，速度;周转率;高速，快速\n
    </string>

    <!--编程笔记-->
    <string name="programming">
        编程笔记·李彬\n
        ●01.Android的系统架构\n
        　　(1)操作系统层OS：linux内核\n
        　　(2)HAL,硬件抽象层，设备内核驱动的抽象接口\n
        　　(3)native C/C++ Libraries和Android运行环境RunTime\n
        　　(4)应用程序框架Application Framework\n
        　　(5)应用程序Application\n
        ●02.小常识\n
        　　(1)File文件所在文件夹存在时，写入数据时自动创建；不存在，则需调用mkdir(),当父类的父类也不存在是应调用mkdirs(),创建父类文件夹。\n
        　　(2)从string中获取的文章字符串，有换行的情况下，会有空格，应先去除空格再用\n
        　　(3)MarginLayoutParams是viewGroup的父类\n
        　　(4)ViewDragHelper滑动控制类，子类有DrawerLayout与SlidingPaneLayout\n
        　　(5)dalvik是运行时编译，ART是安装时就进行编译。目前采用的是ART模式\n
        　　(6)drawable文件，true，false，不同时出现的话，true，必须在前，文件效果才有效\n
        　　(7)Makefile机制:组合文件，进行自动的可控制的编译（待加强）\n
        　　(8)multidex参见错误统计表.xlsx\n
        ●03.ADB命令行：\n
        　　(1)安装apk：adb install 路径\n
        　　(2)向手机传输文件：\n
        　　adb push C:/WorkSpace/aa.txt /storage/emulated/0/AmapSdk\n
        　　(3)手机向电脑传输文件：\n
        　　adb pull /storage/emulated/0/AmapSdk C:/WorkSpace/aa.txt\n
        　　(4)录制视频：\n
        　　adb shell screenrecord /storage/emulated/0/AmapSdk/test.mp4\n
        　　(5)查看系统盘符：adb shell df\n
        ●04.Intent：意图，分显式与隐式两种，显示是指定了component属性，明确启动哪个组件，\n
        　　(1)构造函数：可以是类名或者action（setClass）\n
        　　(2)操作类型action：Intent中只能存在一个，存在则必须有一个相同，setAction()，xml中可存在多个。\n
        　　(3)类别筛选category：Intent中存在几个匹配几个，xml中可存在多个。\n
        　　(4)数据类型data与type：setDataAandType()，地址有特定规则，要么同时设置，要么单独只设置一个。\n
        　　(5)启动模式LaunchMode四种（manifest中用）：standard（标准），singleTop（栈顶不创建），singleTask（单例，独一份，再次进入后，清空之前在其上的页面），singleInstance（独立栈中的独一份）\n
        　　(6)标志也即启动模式（Intent中用）：FLAG_ACTIVITY_NEW_TASK(需要搭配FLAG_ACTIVITY_CLEAR_TASK使用),FLAG_ACTIVITY_SINGLE_TOP,FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS(跳转页面后自动finish,android:excludeFromRecents="true"，目前未起作用)\n
        　　(7)数据传递bundle：Intent内部已经封装好，不用自己封了，serializable，parcelable，也可以转成json字符串传过去\n
        ●05.页面跳转顺序:\n
        　　(1)A启动 A.onCreate->A.onStart->A.onResume->\n
        　　(2)在A中启动B A.onPause->B.onCreate->B.onStart->B.onResume->A.onStop\n
        　　(3)关闭B B.onPause->A.onRestart->A.onStart->A.onResume->B.onStop->B.onDestory\n
        ●06.view的基础知识：屏幕的坐标原点是左上角，向右X轴正方向，向下Y轴正方向\n
        　　(1)View中提供的获取坐标方法：\n
        　　　　getLeft()与getRight()都是View自身到父布局左边的距离\n
        　　　　getTop()与getBottom()都是View自身到父布局顶边的距离\n
        　　　　x，y，translationX，translationY。\n
        　　(2)MotionEvent中的方法：\n
        　　　　GetX()与getY()是视图坐标，相对坐标，即是触摸点到它到父布局左边与顶边的距离\n
        　　　　GetRawX()与getRawY()是绝对坐标，即是触摸点到屏幕左边与顶边的距离\n
        　　(3)TouchSlop：最小滑动距离，获取方法：ViewConfiguration.get(this).scaledTouchSlop，zoom中有使用\n
        　　(4)VelocityTracker：速度跟踪器，只在move中有用，up抬起时为0\n
        　　(5)GestureDetector：手势检测，相关方法：单击，拖动，滑动，长按，双击。\n
        　　(6)Scroller（待深入研究）：弹性滑动对象，与view中的computeScroll方法配合。\n
        　　(7)View的OnTouchListener优先于onTouchEvent，返回true，onTouchEvent不会执行；平常调用的点击事件onClickListener也不会执行。\n
        　　(8)requestDisallowInterceptTouchEvent(boolean)强制请求分发触摸事件。\n
        　　(9)activity中获取宽高onWindowFocusChanged，view.post(runnable),viewTreeObserver.addOnGlobalLayoutListener()\n
        　　(10)onDraw()\n
        　　绘制背景 background.draw(canvas)\n
        　　绘制自己 onDraw\n
        　　绘制children dispatchDraw\n
        　　绘制装饰 onDrawScrollBars\n
        　　(11)view滑动：\n
        　　scrollTo/scrollBy：操作简单，适合对View内容的滑动；\n
        　　动画：操作简单，主要适用于实现复杂的动画效果；\n
        　　改变布局参数，操作稍微复杂，适用于有交互的View。\n
        ●07.自定义View中比较重要的回调方法：\n
        　　第一次进入时的顺序回调\n
        　　(01)onFinishInflate()：从XML加载组件完成后回调；\n
        　　(02)onAttachedToWindow()：组件放入窗口时回调\n
        　　(03)onWindowVisibilityChanged(int)：当包含该组件的窗口可见性发生改变时回调\n
        　　(04)onMeasure()：测量view宽高\n
        　　EXACTLY,精确值模式，具体数字如100dp或者match_parent，默认即为EXACTLY；\n
        　　AT_MOST,自适应模式，warp_content,需要用setMeasureDimension(width,height)设置算好的宽高；\n
        　　UNSPECIFIED，想要多大即多大，所以可以超过屏幕尺寸，显示不下的在屏幕之外；用于系统内部，目前没用过。\n
        　　(05)onSizeChanged()：组件大小改变时回调；\n
        　　(06)onLayout()：控件内的子控件的显示位置，自定义ViewGroup时用\n
        　　(07)onDraw()：绘制所需要显示的内容\n
        　　(08)onWindowFocusChanged()：当包含该组件的窗口失去或的得到焦点时回调\n
        　　退出时的顺序回调onWindowVisibilityChanged->onWindowFocusChanged->onDetachedFromWindow
        　　非顺序回调：\n
        　　(09)onTouchEvent()：触摸事件，不消费ACTION_DOWN的话，之后的也不会消费，消费的话down，move，up，统一消耗。\n
        　　(10)onFocusChanged()：当该组件焦点发生改变时回调\n
        　　(11)onKeyDown()：键盘键按下\n
        　　(12)onKeyUp()：键盘键按下后后抬起\n
        　　(13)onTrackballEvent()：发生轨迹球事件时回调\n
        　　(14)onDetachedFromWindow()：组件从窗口移除时回调\n
        ●08.触摸事件机制，传递顺序:activity->window->view,方法回调有：（默认返回false）\n
        　　(1)disPatchTouchEvent(MotionEvent e)（分发事件，一般不用管）\n
        　　(2)onInterceptTouchEvent(MotionEvent e)， ViewGroup独有\n
        　　(3)onTouchEvent(MotionEvent e)\n
        　　(4)触摸按钮时的回调机制：A包B包C\n
        　　A.disPatch -> A.intercept ->B.disPatch -> B.intercept ->C.disPatch -> C.touch -> B.touch -> A.touch\n
        ●09.Canvas方法：\n
        　　(1)translate(x,y)：将原点(0,0)移动(x,y)\n
        　　(2)rotate(a,x,y)：将画布以(x,y)为中心旋转a度\n
        　　(2)scale(x,y,px,py)：将画布缩放\n
        　　(2)skew(x,y)：将画布倾斜\n
        　　(3)save(),saveLayer(),saveLayerAlpha():保存画布当前状态，并返回int值，方便移除此状态\n
        　　(4)restore():返回画布此次保存的初始状态\n
        　　(5)restoreToCount():移除画布此次保存的状态\n
        ●10.Paint的重要属性：TextPaint.getFontMetricsInt()\n
        　　(1)setAntialias()与Paint(Paint.ANTI_ALIAS_FLAG) ：抗锯齿\n
        　　(2)setStrokeWidth(),宽度是从中间开始计算的\n
        　　(3)setARGB(),setAlpha(),setTextSize(),setStyle(),setColor().\n
        　　textHeight=paint.descent()-paint.ascent()\n
        　　(4)基准线是baseline\n
        　　(5)ascent：字体在baseline上方被推荐的距离（一些字体制作商需要参考这个）\n
        　　(6)descent：字体在是baseline下方被推荐的距离（一些字体制作商需要参考这个）\n
        　　(7)top：ascent的最大值\n
        　　(8)bottom：descent的最大值\n
        　　(9)getTextBounds(String text, int start, int end, Rect bounds):获取文字宽高\n
        　　(10)measureText(text)：获取文字宽度\n
        　　(11)ColorMatrix\n
        　　(12)PorterDuffXfermode（不好用），\n
        　　(13)Shader，着色器，渲染器：（TileMode三中模式：CLAMP拉伸；REPEAT重复；MIRROR镜像）\n
        　　　　BitmapShader：位图\n
        　　　　LinearGradient：线性\n
        　　　　RadiolGradient：光束\n
        　　　　SweepGradient：梯度\n
        　　　　ComposeShader：混合\n
        　　(14)PathEffect画线用，结合Path的lineTo来使用\n
        　　　　CornerPathEffect：拐角圆滑\n
        　　　　DiscretePathEffect：相当于画了一条毛茸茸的线\n
        　　　　DashPathEffect：画虚线\n
        　　　　PathDashPathEffect：升级的画虚线\n
        　　　　ComPosePathEffect与SunPathEffect：组合前几者\n
        ●11.动画类型分为三种：逐帧动画，补间动画，属性动画：\n
        (1)逐帧动画（Frame Animation）：AnimationDrawable相对于animation-list\n
        (2)补间动画：\n
        位移：TranslateAnimation对应的xml：translate\n
        缩放：ScaleAnimation 对应的xml：scale\n
        旋转：RotateAnimation 对应的xml：ratate\n
        透明度：AlphaAnimation 对应的xml：alpha\n
        组合：AnimationSet 对应的xml：set\n
        ●12.属性动画：ValueAnimator包括：ObjectAnimator，AnimatorSet组合，也有相应的xml对应字段，动画属性值：\n
        　　(1)translationX、translationY，增量平移\n
        　　(2)rotation、rotationX、rotationY 旋转\n
        　　(3)pivotX、pivotY没看出和rotation有什么区别\n
        　　(4)scaleX、scaleY 缩放\n
        　　(5)x、y 最终位置\n
        　　(6)alpha 透明度 默认为1，不透明，0代表完全透明，即不可见\n
        　　(7)PropertyValuesHolder，ObjectAnimator.ofPropertyValuesHolder()\n
        　　(8)Value的主要方法：addUpdateListener()\n
        　　(9)过度动画（Transiton Animation）：属性动画的变种。\n
        ●13.AnimatorSet属性：palyTogether()，playSequentially()，play().with()、befor()、after();来控制动画的播放规则\n
        ●14.动画插值器TimeInterpolator，计算时间流逝的百分比；类型估值器TypeEvaluaor,计算当前的属性值\n
        　　(1)LinearInterPolator：匀速\n
        　　(2)AccelerateInterpolator：匀加速\n
        　　(3)AccelerateDecelerateInterpolator：起始加速，末尾减速\n
        　　(4)CycleInterpolator：循环播放，正弦曲线\n
        　　(5)DecelerateInterpolator：匀减速\n
        ●15.StateListDrawable属性值item:selector\n
        　　(1)android:state_active：代表是否处于激活状态\n
        　　(2)android:state_checkable：代表是否处于可勾选状态\n
        　　(3)android:state_checked：代表是否处于已勾选状态\n
        　　(4)android:state_enabled：代表是否处于可用状态\n
        　　(5)android:state_first：代表是否处于开始状态\n
        　　(6)android:state_focused：代表是否处于已得到焦点状态\n
        　　(7)android:state_last：代表是否处于结束状态\n
        　　(8)android:state_middle：代表是否处于中间状态\n
        　　(9)android:state_pressed：代表是否处于已被按下状态状态\n
        　　(10)android:state_selected：代表是否处于选中状态\n
        　　(11)android:state_window_focused：代表窗口是否处于已得到焦点状态\n
        ●16.shape属性\n
        　　(1)corners：圆角\n
        　　(2)gradient：渐变色\n
        　　(3)padding：内边距\n
        　　(4)size：基本没用\n
        　　(5)solid：内部填充色\n
        　　(6)stroke：边框，以及虚边\n
        ●17.布局动画：LayoutAnimationController，在MainAdapter中有使用\n
        　　(1)LayoutAnimationController.ORDER_NORMAL：顺序\n
        　　(2)LayoutAnimationController.ORDER_RANDOM：随机\n
        　　(3)LayoutAnimationController.ORDER_REVERSE：反序\n
        ●18.SVG:VectorDrawable（vector静态效果）、AnimatedVectorDrawable（animated-vector）：animated-vector组合objectAnimator与vector形成动态的动画效果\n
        ●19.handler执行\n
        　　(1)handler中执行enqueueMessage()方法将消息放入队列中，等待loop循环并找到此消息。\n
        　　(2)Looper.loop()方法是死循环，其中选取消息的方法Message msg = queue.next();也是一个死循环，直到取到消息，开始往下执行；\n
        　　(3)取到消息后开始执行handler的分发方法dispatchMessage()开始回调，方法执行完成后，此次消息处理完成。\n
        　　(4)handler分发dispatchMessage()：先检测message中的callback是否为空，不为空消费此消息；为空则检测handler自己的callback，返回出rue则消费此消息，终止传递；为false则执行handleMessage()。\n
        ●20.IPC机制：多进程间通信\n
        　　会造成的问题：\n
        　　(1)静态成员和单例模式完全失效：不同进程间的静态和单例是互相独立的\n
        　　(2)线程同步机制完全失效：不同进程间的线程也是互相独立的\n
        　　(3)SharedPreferences可靠性下降：不支持两个进程同时读写，有一定几率会丢数据\n
        　　(4)application多次创建：新进程代表新的虚拟机的启动\n
        　　通信方式：序列化serializable与parcelable，Binder（待深入AIDL），Intent，共享文件，Messenger（待深入研究AIDL），ContentProvider，socket网络通信。\n
        ●21.Serializable，java数据序列化，可自己重写序列化与反序列化过程\n
        　　(1)FileUtils中serialize(path,value)（序列化）与deserialize(path)（反序列化）运用\n
        　　(2)静态成员变量属于类不属于对象，不参与序列化\n
        　　(3)用transient关键字标记的成员变量不参与序列化\n
        ●22.Parcelable，Android数据序列化，在CourseEntity中有应用\n
        ●23.本地保存数据时以及简单的数据通讯可以使用serializable，Parcelable主要用在内存序列化上，建议比较大的数据对象传输是使用。\n
        ●24.Binder实现IBinder接口（aidl快速实现Binder的工具），主要用在Service开发中，AIDL在PairServiceA中有应用\n
        ●25.线程Thread：AsyncTask，HandlerThread，IntentService，ThreadPoolExecutor。\n
        　　(1)Executors.newFixedThreadPool()，都为核心线程，且数量固定的线程池，无超时机制。\n
        　　(2)Executors.newCachedThreadPool()，无核心，非核心线程数不限数量，有超时机制60s，适合多图加载这种文件小而多的任务。\n
        　　(3)Executors.newScheduledThreadPool()，核心固定，非核心不限，闲置时超时回收，主要用于执行定时任务和具有固定周期的重复任务。\n
        　　(4)Executors.newSingleThreadExecutor()，仅创建一个单核心线程，任务串行。\n
        ●26.Bitmap，缓存机制LruCache与DiskLruCache，BitmapFactory.Options\n
        　　(1)inSampleSize，整数，最小为1，等比缩小原图宽高。\n
        　　(2)inJustDecodeBounds，true时只解析宽高不加载到内存中。\n
        ●27.JNI和NDK编程，JNI是java的本地交互，NDK是Android提供得工具集合，可以在android中更加方便的通过JNI来访问本地代码，如C，C++，NDK\n
        还提供了交叉编译器，开发人员只需要简单的修改mk文件就可以生成特定的CPU平带的动态库，使用NDK有如下好处：\n
        　　(1)提高代码的安全性。so库反编译比较困难\n
        　　(2)可以使用目前已有的C/C++开源库\n
        　　(3)便于平台间的移植。\n
        　　(4)提高程序在某些特定情形下的执行效率，但是并不能明显提升Android程序的性能。\n
        　　(5)在cmd终端中进入到main目录下 cd (具体路径)/apiutils/src/main\n
        　　执行此语句  javah -d jni -classpath ../../build/intermediates/classes/debug com.sky.NDKString  会自动生成jni文件com_sky_NDKString.h,自定义.c的file\n
        ●28.性能优化\n
        　　(1)布局优化：include，merge，ViewStub，减少层级嵌套，加强view复用。\n
        　　(2)绘制优化：在onDraw中不要创建新对象，不执行浩氏人物，view的绘制帧率保证60fps是最佳的，每帧所需时间不超过16ms（16ms=1000/60）.\n
        　　(3)内存泄漏：分析工具MAT。\n
        　　(4)属性动画导致的内存泄漏：无限循环需要关闭。\n
        　　(5)响应速度优化和ANR日志分析：避免在主线程中做耗时操作，日志所在：/data/anr/traces.txt\n
        　　(6)Recycler与bitmap优化\n
        　　(7)线程优化：灵活应用线程池，避免创建大量线程。\n
        　　(8)避免创建过多对象；\n
        　　　灵活并酌情使用枚举类型；\n
        　　　常量使用static final来修饰。\n
        　　　使用android特有的数据结构，比如SparseArray和Pair等；\n
        　　　适当使用软引用与弱引用；\n
        　　　采用内存加磁盘缓存；\n
        　　　尽量使用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。\n
        ●29.window与WindowManager ipc机制\n
        　　(1)addView(v,layoutparam)\n
        　　(2)updateViewLayout(v,layoutparam)\n
        　　(3)rempveView(v)\n
        ●30.ProGuard，参见app下的proguard文件，App研发录\n
        　　(1)压缩Shrink：侦测并移除代码中的无用类，字段，方法和特性。\n
        　　(2)优化Optimize：对字节码进行优化，移除无用的指令。\n
        　　(3)混淆Obfuscate：使用a、b、c、d这样简短而无意义的名称，对类、字段和方法进行重命名。\n
        　　(4)预检Preveirfy：在java平台上对处理后的代码进行预检。\n
        ●31.\n
        　　(1)TelephonyManager：电话管理器；\n
        　　(2)SmsManager：短信管理器\n
        　　(3)AudioManager：音频管理器\n
        　　(4)Vibrator：振动器\n
        　　(5)AlarmManager：手机闹钟服务\n
        ●32.\n
        　　(1)MediaPlayer：音频\n
        　　(2)SoundPool：音频\n
        　　(3)VideoView：播放视频\n
        　　(4)mediaRecorder：录制音频\n
        ●33.Math的三角函数：\n
        　　var angle = 30.0//角度\n
        　　val radians = Math.PI * angle / 180//转换成弧度\n
        　　val ix = 200 * Math.cos(radians)\n
        　　val iy = 200 * Math.sin(radians)\n
        　　0-360 度，Cos取值范围1..0..-1..0..1，即+- -+，Sin 取值范围0..1..0..-1..0,即++- -\n
        　　以x=Cos,y=Sin算为++，-+，- -，+-，即一二三四象限，以X正轴1为起点，逆时针方向画圆，画布上Y轴正负颠倒，所以是顺时针方向画圆\n
        　　以x=Sin,y=Cos算为++，+-，- -，-+，即一四三二象限，以Y正轴1为起点，顺时针方向画圆，画布上Y轴正负颠倒，所以是逆时针方向画圆\n
        　　val ix = 200 * Math.sin(radians)\n
        　　val iy = 200 * Math.cos(radians)\n
        ●34.排序算法：\n
        　　(1)冒泡排序：选定一端，两相比较，顺序错误则交换。\n
        　　(2)选择排序：每次选出最大或最小的放在队首，直到完成。\n
        　　(3)插入排序：排序头两个数据，然后每次增加一个数据来循环，直到完成。\n
        ●35.java内存\n
        　　(1)寄存器：我们在程序中无法控制\n
        　　(2)栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中，还有能确定的字符串\n
        　　(3)堆：存放用new产生的数据\n
        　　(4)静态域：存放在对象中用static定义的静态成员\n
        　　(5)常量池：存放常量\n
        　　(6)非RAM(随机存取存储器)存储：硬盘等永久存储空间\n
        ●.linked与array做比\n
        　　(1)单纯顺序添加，array胜\n
        　　(2)随机添加array更胜\n
        　　(3)随机删除linked险胜\n
        　　(4)随机查array时间固定，link越靠后越耗时\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        　　(4)\n
        　　(5)\n
        　　(6)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        　　(4)\n
        　　(5)\n
        　　(6)\n
    </string>
    <string name="designPattern">
        设计模式\n
        ●01.面向对象的六大原则\n
        　　(1)单一职责原则(Single Responsibility Principle)：不同功能间拆分成独立的类（与接口隔离原则相类似，都是大类的细化拆分）\n
        　　(2)开闭原则（Open Close Principle）：让程序更稳定，更灵活；依赖于抽象，独立于实现。在文件来说就是隐藏实现private，暴露调用方法public。\n
        　　(3)里氏代换原则（Liskov Substitution Principle）：构建扩展性更好的系统；核心依然依赖于抽象，拆分出共同的实现方法，单独编写不同的实现，依赖于面向对象三大特性中的继承与多态。\n
        　　(4)依赖倒转原则（Dependence Inversion Principle）：让项目拥有变化的能力；模块间的依赖通过抽象发生，实现类之间不发生直接依赖关系，依赖于三大特性中的多态。\n
        　　(5)接口隔离原则（Interface Segregation Principle）：系统拥有更高的灵活性；接口中方法的拆分，实现类只需要继承自己需要的接口\n
        　　(6)迪米特法则（最少知道原则）（Demeter Principle）：更好的扩展性；类似于MVP，单一指向\n
        ●02.设计模式的分类\n
        　　总体来说设计模式分为三大类：\n
        　　(1)创建型模式，共五种：\n
        　　工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。\n
        　　(2)结构型模式，共七种：\n
        　　适配器模式：类（在MVP中用过，类似于两类重用一个方法）、对象（在一个类里的一个方法中调用另一个类里的相同方法）、接口（三种适配器模式）；\n
        　　（后六种是对象适配器的衍生）：\n
        　　装饰器模式（同接口间两个类的操作）->代理模式（与装饰器基本相同，细微差别具体分析）->外观模式（相当于类的组合排序）；\n
        　　桥接模式（公共管理器，动态替换其中的对象）->组合模式（地址选择中有运用，有点类似于linked）->享元模式（一般结合工厂模式，jdbc连接池）。\n
        　　(3)行为型模式，共十一种：\n
        　　父类与子类：一个方法不同的实现，公共方法的提取形成的两种模式：策略模式、模板方法模式；适用于算法的改变。\n
        　　两个类之间：观察者模式、迭代子模式(数组迭代器)、责任链模式（handler的循环链）、命令模式（相当于逐级传递）。\n
        　　类的状态：备忘录模式（备份模式）、状态模式（状态的切换，卫星菜单栏，侧滑栏）。\n
        　　通过中间类：访问者模式、中介者模式、解释器模式。\n
        　　(4)其实还有两类：并发型模式和线程池模式。\n
        ●03.单例模式：应用最广的模式，几种模式实现方式：\n
        　　(1)饿汉模式：第一次加载是就初始化，如果不使用的话是一种资源的浪费\n
        　　(2)懒汉模式（synchronized修饰方法）：第一次使用时才初始化，但是每次使用时，必须同步，一样会造成资源的浪费\n
        　　(3)双重检索模式：目前使用最多的，但是在高并发的环境下有一定缺陷。\n
        　　(4)静态内部类模式：推荐使用的\n
        　　(5)枚举模式：线程安全，反序列化不生成新实例。\n
        　　(6)单例容器，统一调配使用。系统服务的获取就是单例容器的应用\n
        　　(7)LayoutInflater\n
        ●04.建造者模式 Builder：二次封装，犹如三层楼，第一层设置参数，第二层通过build再次复制参数，第三层开始使用。只有一层的话，当第一层发生变化，使用时也就发生了变化，所以需要加入第二层，只要不执行build创建，第一层可以随便改。\n
        　　(1)dialog的创建\n
        　　(2)WindowManager\n
        ●05.原型模式：浅复制与深复制，当对象中的属性都为八种基本类型时，浅复制即可；其他引用类型需用深复制才能拷贝一份独立的对象。\n
        　　(1)Intent，Array的clone\n
        ●06.工厂模式：Factory Pattern，应用最广泛的模式，只存在一个工厂类的时候可以写成静态工厂模式。抽象产品接口，产品实现类，工厂，调用。\n
        　　(1)Iterable接口等等\n
        ●07.抽象工厂模式：Abstract Factory Pattern，抽象产品接口，产品实现类，抽象工厂（内含生成产品的抽象方法），实现类工厂，调用。\n
        　　(1)MediaPlayer的创建\n
        ●08.策略模式：工厂模式的变种，一种产品的多种实现，工厂与调用结合依赖于抽象产品（多态）（OCP与DIP原则）\n
        　　(1)动画的实现应用了策略模式\n
        ●09.状态模式：此模式模式和策略模式基本相同，但应用场景不同，适用于状态改变后，之后的操作都不一样。\n
        　　(1)WiFi的模式\n
        ●10.责任链模式：Iterator Pattern，一个事件，第一级处理不了，则依次传递到下一级，最后被某个对象所处理，则为纯责任链，如还没处理，则为不纯\n
        　　(1)触摸事件的分发\n
        　　(2)用广播也可以实现责任链模式。\n
        ●11.解释器模式：Interpreter Pattern，使用较少。\n
        　　(1)计算器可以使用解释器来写\n
        ●12.命令模式：Command Pattern，接收者（执行者），命令者，请求者，客户端。\n
        　　(1)android的输入事件\n
        ●13.观察者模式：对象解耦；一个对象改变，所有依赖于他的对象都会得到通知。类似于责任链的线性传递，转成并行传递，相当于一个是串行，一个是并行。\n
        　　(1)adapter适配器\n
        　　(2)BroadcastReceiver\n
        　　(3)事件总线\n
        ●14.备忘录模式：Originator，（被保存的对象）创建备忘录Memoto；Memoto需要存取的属性值，Caretaker保存和读取Memoto。\n
        　　(1)activity被杀死时备份\n
        　　(2)游戏存档\n
        ●15.迭代器模式：Iterator，也叫游标模式Cursor。\n
        　　(1)Iterator迭代器，iterator与iterable联合使用\n
        　　(2)数据库中的游标\n
        ●16.模板方法模式\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        　　(4)\n
        　　(5)\n
        　　(6)\n
    </string>
    <string name="thinkInJava">
        Java编程思想\n
        ●01.万物皆对象，程序就是对象的集合。具有状态，行为，标识。\n
        ●02.java三大特性：封装，继承，多态。\n
        ●03.封装，隐藏实现，暴露必须的方法\n
        ●04.继承，依赖于基类，独立于实现(开闭原则)\n
        　　(1)源类（基类，超类，父类）\n
        　　(2)副本（导出类，继承类，子类）\n
        　　(3)纯粹替代，替代原则，is-a（是一个）无添加；is-like-a（像一个）有添加新方法。\n
        ●05.多态，依赖于继承，策略模式，状态模式。\n
        　　(1)前期绑定，后期动态绑定\n
        ●06.单根继承结构\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        　　(4)\n
        　　(5)\n
        　　(6)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        　　(4)\n
        　　(5)\n
        　　(6)\n
        ●.\n
        　　(1)\n
        　　(2)\n
        　　(3)\n
        　　(4)\n
        　　(5)\n
        　　(6)\n
    </string>
    <string name="gitCommand">
        git命令\n
        git config --global user.email 邮箱\n
        git config --global user.name 名字\n
        git add  添加 后边加.，全部暂存；后边跟详细名称，则是单传。
        git status （-s）加上-s，只显示新增改变的内容，无s显示改变的内容在暂存区里的状态
        git diff 尚未缓存的改动
        git diff --cache 查看已缓存的改动
        git diff head 查看已缓存的与未缓存的所有改动
        git diff --stat 显示摘要
        git commit -m 双引号（注释）
        ls (-a) 文件夹内的文件列表
        vim 编辑器
        ?? 代表未添加到暂存区
        A 代表添加暂存区
        M 代表修改的文件
        fm -rf 删除文件
    </string>
    <string name="gradle">
        gralde结构

    </string>
</resources>
